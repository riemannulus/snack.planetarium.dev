<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><title>플라네타리움 엔지니어링 스낵</title><link rel="self" href="https://snack.planetarium.dev/kor/index.xml"/><link rel="alternate" href="https://snack.planetarium.dev/kor/" title="플라네타리움 엔지니어링 스낵"/><link rel="alternate" href="https://snack.planetarium.dev/eng/" hreflang="en" title="Planetarium Engineering Snack"/><updated>2020-04-28T00:00:00+00:00</updated><id>https://snack.planetarium.dev/kor/</id><entry><title>Libplanet 0.9 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/04/libplanet-0.9/" title="Libplanet 0.9 릴리스"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/04/libplanet-0.9/" hreflang="en" title="Libplanet 0.9 Released"/><id>https://snack.planetarium.dev/kor/2020/04/libplanet-0.9/</id><published>2020-04-28T00:00:00+00:00</published><updated>2020-04-28T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. &lt;a href="https://libplanet.io/">Libplanet&lt;/a>의 아홉 번째 마이너 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.9.0">0.9 버전&lt;/a>이
릴리스되었습니다.&lt;/p>
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때,
그러한 게임들이 매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는
공용 라이브러리입니다.&lt;/p>
&lt;p>이번 버전부터 Libplanet은 여러 NuGet 패키지로 배포되는데요.
Libplanet의 외연이 확장되어 일부 의존 라이브러리를 모든 애플리케이션에서
포함하기에는 무거워졌기 때문입니다.&lt;/p>
&lt;p>이 글에서는 0.9 버전의 새로운 NuGet 패키지들을 소개하며 주요 변경 사항들에
대해서도 다루겠습니다.&lt;/p>
&lt;h2 id="libplanetrocksdbstore">&lt;a href="https://www.nuget.org/packages/Libplanet.RocksDBStore/">Libplanet.RocksDBStore&lt;/a>&lt;/h2>
&lt;p>Libplanet.RocksDBStore는 새로 추가된 NuGet 패키지로,
Lipblanet의 &lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Store.IStore.html">&lt;code>IStore&lt;/code> 인터페이스&lt;/a>를 &lt;a href="https://rocksdb.org/">RocksDB&lt;/a> 백엔드로 구현한
&lt;code>RocksDBStore&lt;/code> 클래스를 포함합니다. &lt;code>RocksDBStore&lt;/code>는 내부 테스트 결과 기존의
&lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Store.DefaultStore.html">&lt;code>DefaultStore&lt;/code>&lt;/a>에 비해 쓰기는 약 10배 읽기는 약 2배 이상
빨라졌으며, 압축 등의 효과 덕에 기존에 비해 15% 이하의 저장 공간만을 차지하게
됐습니다.&lt;/p>
&lt;p>위와 같은 장점에도, C++로 작성된 RocksDB 네이티브 바이너리를 애플리케이션과
함께 배포해야 하기 때문에 일부 플랫폼에서는 이용이 곤란할 수 있습니다.
따라서 &lt;code>RocksDBStore&lt;/code> 클래스는 Libplanet 패키지가 아닌
Libplanet.RocksDBStore라는 별도 NuGet 패키지로 배포하게 되었으며,
Libplanet 패키지에는 여전히 &lt;code>DefaultStore&lt;/code>가 제공됩니다. 따라서 개발할 때는
설치가 간편한 &lt;code>DefaultStore&lt;/code>를 쓰고 테스트 및 실제 배포시에만 &lt;code>RocksDBStore&lt;/code>를
쓰거나, RocksDB 바이너리를 제공하기 어려운 플랫폼에 한해 &lt;code>DefaultStore&lt;/code>를 쓰는
식의 활용이 가능합니다.&lt;/p>
&lt;p>자세한 내용은 이승훈 님이 쓰신 &lt;a href="https://snack.planetarium.dev/kor/2020/04/rocksdb/">Libplanet RocksDB 적용기&lt;/a>에서 볼 수 있습니다.&lt;/p>
&lt;h2 id="여러-피어로부터-블록-받기">여러 피어로부터 블록 받기&lt;/h2>
&lt;p>이제까지 &lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Net.Swarm-1.html">&lt;code>Swarm&amp;lt;T&amp;gt;&lt;/code> 클래스&lt;/a>의 &lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Net.Swarm-1.html#Libplanet_Net_Swarm_1_PreloadAsync_System_Nullable_TimeSpan__IProgress_Libplanet_Net_PreloadState__IImmutableSet_Libplanet_Address__EventHandler_Libplanet_Net_PreloadBlockDownloadFailEventArgs__CancellationToken_">&lt;code>PreloadAsync()&lt;/code>&lt;/a> 및
&lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Net.Swarm-1.html#Libplanet_Net_Swarm_1_StartAsync_TimeSpan_TimeSpan_CancellationToken_">&lt;code>StartAsync()&lt;/code> 메서드&lt;/a>는 네트워크에 쌓인 블록을 따라잡기
위해 하나의 피어에게 그간의 모든 블록을 요청하여 받게 되어 있었습니다.
쌓인 블록이 많을 경우 하나의 피어에게만 받다 보니 오래 걸리기 일쑤였고,
운이 안 좋으면 서로 통신이 아주 느린 피어에게 블록을 요청해 받기까지 아주 오래
걸리는 경우도 있었습니다. 블록을 보내주는 쪽에서도 홀로 큰 부담을 져야 하는데,
배포되는 애플리케이션에 기본값으로 설정된 시드 노드의 경우 그 부담이 무시하기
힘들 정도였습니다.&lt;/p>
&lt;p>이번 버전부터는 블록을 여러 피어에게 고루 받도록 개선되었으며, 그 가운데
특별히 느린 피어가 끼더라도 전체 블록을 받는 시간이 크게 늦어지는 일도
크게 줄었습니다.&lt;/p>
&lt;h2 id="서명된-앱-프로토콜-버전">서명된 앱 프로토콜 버전&lt;/h2>
&lt;p>지난해, &lt;a href="https://snack.planetarium.dev/kor/2019/05/libplanet-0.3/#%EB%B2%84%EC%A0%84%EC%9D%B4-%EB%8B%A4%EB%A5%B8-%EB%85%B8%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%82%AC%EC%9D%84-%EB%95%8C-%EB%B0%98%EC%9D%91%ED%95%98%EB%8A%94-api">Libplanet 0.3에는 &lt;code>Swarm&amp;lt;T&amp;gt;()&lt;/code> 생성자에 &lt;code>appProtocolVersion&lt;/code> 매개변수가
추가됐습니다.&lt;/a> 서로 프로토콜이 호환되는 노드끼리만 통신하고, 호환되지
않는 경우의 처리를 앱에 따라 적절히 처리할 수 있도록 한 것입니다.&lt;/p>
&lt;p>저희 팀 역시 이 기능을 활용했고, 더 높은 버전의 노드와 조우할 경우 소프트웨어
업데이트를 유도하는 용도로 썼습니다. 그러나 이렇게 활용하니, 변조된
소프트웨어가 악의적으로 (실제로는 발표된 적 없는) 높은 버전 숫자를 내보이게
하여 다른 노드들이 거짓 소프트웨어 업데이트를 시도하도록 공격하는 데에 쓰일
수 있다는 것을 알게 됐습니다.&lt;/p>
&lt;p>이러한 일을 피할 수 있도록, &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.int32">&lt;code>System.Int32&lt;/code>&lt;/a>로 표현되던
앱 프로토콜 버전은 이제 서명과 서명자 등 여러 메타데이터를 포함하는
&lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Net.AppProtocolVersion.html">&lt;code>AppProtocolVersion&lt;/code> 자료형&lt;/a>으로
바뀌었습니다. 앱 프로토콜 버전은 서명되어야 하며, 각 노드는 &lt;code>Swarm&amp;lt;T&amp;gt;()&lt;/code>
생성자의 &lt;code>trustedAppProtocolVersionSigners&lt;/code> 매개변수로 어떤 서명자의
앱 프로로콜 버전을 신뢰할지 &lt;em>각자&lt;/em> 정하게 됩니다.&lt;/p>
&lt;p>이러한 방식은 각 노드들을 의도하지 않은 (변조된) 소프트웨어 업데이트로부터
보호하는 동시에, 각 노드들이 원한다면 자유롭게 포크된 다른 애플리케이션 로드맵을
선택할 자유도 제공합니다.&lt;/p>
&lt;h2 id="키-저장소">키 저장소&lt;/h2>
&lt;p>지난해, &lt;a href="https://snack.planetarium.dev/kor/2019/11/libplanet-0.7/#%EA%B0%9C%EC%9D%B8%ED%82%A4%EB%A5%BC-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EC%A0%80%EC%9E%A5%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%ED%82%A4-%EC%A0%80%EC%9E%A5%EC%86%8C-%EA%B5%AC%ED%98%84">Libplanet은 0.7 버전에서 &lt;code>PrivateKey&lt;/code>를 안전하게 저장할 수 있는
&lt;code>ProtectedPrivateKey&lt;/code> 클래스가 추가됐습니다.&lt;/a> 그렇지만
&lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.KeyStore.ProtectedPrivateKey.html">&lt;code>ProtectedPrivateKey&lt;/code>&lt;/a>는 하나의 키만 다룰 뿐으로,
여러 키를 다루려면 애플리케이션 측에서 디렉터리를 만들고 파일명을 결정하고
파일에 쓰는 등의 처리를 알아서 구현해야 했습니다.&lt;/p>
&lt;p>이번 버전에부터는 키를 물리적으로 보존하고 관리하는 기능인
&lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.KeyStore.Web3KeyStore.html">&lt;code>Web3KeyStore&lt;/code>&lt;/a> 클래스가 제공되기 때문에, 더이상 그런 처리를
직접 구현할 필요가 없어졌습니다. 파일 시스템에 &lt;a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3 Secret Storage Definition&lt;/a>
형식으로 키를 보존하는 &lt;code>Web3KeyStore&lt;/code>와 더불어, 그러한 구체적인 보존 방식(구현
세부사항)을 추상화하는 &lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.KeyStore.IKeyStore.html">&lt;code>IKeyStore&lt;/code> 인터페이스&lt;/a> 역시 도입됐습니다.&lt;/p>
&lt;h2 id="planet-명령행-도구">&lt;code>planet&lt;/code>: 명령행 도구&lt;/h2>
&lt;p>&lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Net.Swarm-1.html#Libplanet_Net_Swarm_1__ctor_Libplanet_Blockchain_BlockChain__0__Libplanet_Crypto_PrivateKey_Libplanet_Net_AppProtocolVersion_System_Int32_System_String_System_Nullable_System_Int32__IEnumerable_Libplanet_Net_IceServer__Libplanet_Net_DifferentAppProtocolVersionEncountered_IEnumerable_Libplanet_Crypto_PublicKey__">&lt;code>Swarm&amp;lt;T&amp;gt;()&lt;/code> 생성자&lt;/a>는 &lt;a href="https://snack.planetarium.dev/kor/2020/02/libplanet-0.8/#%EC%A0%9C%EB%84%88%EC%8B%9C%EC%8A%A4-%EB%B8%94%EB%A1%9D-%EC%83%81%EC%A0%95">지난 버전부터 특정 제너시스 블록을 상정하게
됐고&lt;/a>, &lt;a href="#%EC%84%9C%EB%AA%85%EB%90%9C-%EC%95%B1-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%B2%84%EC%A0%84">이번 버전부터는 앱 프로토콜 버전을 서명하게 됐습니다.&lt;/a> 이와 같은
값들은 암호학 알고리즘의 결과를 포함하기 때문에, 사람이 임의로 아무 값이나
넣을 수 없습니다. 그렇지만 개발 과정에서는 임의의 값들을 채워봐야 할 일이 많기
때문에, 이 때마다 Libplanet API를 C# 대화형 셸이나 PowerShell 등에서 호출하여
원하는 값을 계산하는 것은 그것대로 여간 번거로운 일이 아니었습니다.&lt;/p>
&lt;p>이러한 작업을 좀더 쉽게 할 수 있도록, 이번 버전부터는 &lt;code>planet&lt;/code>이라는
명령행(&lt;abbr title="command-line interface">CLI&lt;/abbr>) 도구를 함께 배포합니다.
&lt;code>planet&lt;/code> 명령은 여러 서브커맨드를 포함하며, 현재로서는 키 저장소 관리와
앱 프로토콜 버전의 서명 기능을 제공합니다. 이후 임의의 제너시스 블록 생성 등의
기능도 추가될 예정입니다. 자세한 사용법은 &lt;code>planet --help&lt;/code> 명령을 확인해 주세요.&lt;/p>
&lt;p>&lt;code>planet&lt;/code> 명령은 &lt;a href="https://www.nuget.org/packages/Libplanet.Tools/">Libplanet.Tools&lt;/a>라는 NuGet 패키지로 배포되며, .NET Core SDK가
설치된 시스템에서 아래와 같이 설치할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff">&lt;code class="language-bash" data-lang="bash">dotnet tool install -g Libplanet.Tools
&lt;/code>&lt;/pre>&lt;/div>&lt;p>.NET Core SDK가 설치되지 않은 환경이라면 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.9.0">릴리스 페이지&lt;/a>에 첨부된
공식 바이너리를 받아서 설치할 수도 있습니다. 공식 바이너리는 Linux (x64),
macOS (x64), Windows (x64) 세 플랫폼의 버전이 제공되고 있습니다.&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>그 밖의 여러 변경 사항은 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.9.0">전체 변경 내용&lt;/a>에서 확인하실 수 있습니다.&lt;/p>
&lt;p>호기심이 생기신 분들은 설치해서 이용해 보시고, 궁금한 점이 있으시다면 저희 팀이
상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드&lt;/a>에도 놀러오세요!&lt;/p></content><author><name>홍민희</name><uri>https://github.com/dahlia</uri><email>hong.minhee@planetariumhq.com</email></author></entry><entry><title>Libplanet RocksDB 적용기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/04/rocksdb/" title="Libplanet RocksDB 적용기"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/04/rocksdb/" hreflang="en" title="Applying RocksDB to Libplanet"/><id>https://snack.planetarium.dev/kor/2020/04/rocksdb/</id><published>2020-04-17T00:00:00+00:00</published><updated>2020-04-17T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 플라네타리움에서 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>을 만들고 있는 이승훈입니다.&lt;/p>
&lt;p>Libplanet에서는 &lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Store.IStore.html">&lt;code>IStore&lt;/code>&lt;/a>라는 저장계층 추상화 인터페이스와 기본 구현인 &lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Store.DefaultStore.html">&lt;code>DefaultStore&lt;/code>&lt;/a>를 제공하고 있고, Libplanet을 이용하여 만들고 있는 게임 &lt;a href="https://nine-chronicles.com/">Nine Chronicles&lt;/a>도 이를 쓰고 있었습니다. &lt;code>DefaultStore&lt;/code>는 Libplanet에 기본으로 포함되어 곧바로 쓸 수 있다는 장점이 있었지만, 성능이나 저장 공간 효율 측면에서 한계가 있었습니다.&lt;/p>
&lt;p>이에 따라 저희는 여러 대안 저장 방식을 검토한 끝에 Facebook에서 제작한 &lt;a href="https://ko.wikipedia.org/wiki/%ED%82%A4-%EA%B0%92_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4">키–값 데이터베이스&lt;/a> 라이브러리인 &lt;a href="https://rocksdb.org/">RocksDB&lt;/a>가 적합하다고 판단했고, 이를 백엔드로 사용하는 &lt;code>IStore&lt;/code> 구현체인 &lt;a href="https://github.com/planetarium/libplanet/blob/master/Libplanet.RocksDBStore/RocksDBStore.cs">&lt;code>RocksDBStore&lt;/code>&lt;/a>를 만들기로 했습니다. 이번 글에서는 &lt;code>RocksDBStore&lt;/code>를 만들면서 경험한 일들을 공유하려고 합니다.&lt;/p>
&lt;h2 id="의존하는-라이브러리-포함시키기1">의존하는 라이브러리 포함시키기&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/h2>
&lt;p>RocksDB는 압축이나 메모리 할당을 위해 또다른 라이브러리들에 의존합니다. &lt;a href="https://github.com/facebook/rocksdb/wiki/Building-on-Windows">Windows 빌드&lt;/a>와 다르게 macOS와 Linux의 경우 RocksDB 네이티브 라이브러리를 동적 링크 라이브러리 형태(&lt;em>.so&lt;/em> 및 &lt;em>.dylib&lt;/em>)로 사용하기 위해서는 RocksDB가 의존하는 라이브러리들도 시스템에 설치되어 있어야 합니다.&lt;/p>
&lt;p>일반적인 서버 앱에서는 시스템에 모든 의존 라이브러리들을 다 설치하는 것이 자연스러운 일입니다. 서버 앱을 구동하는 시스템은 보통 그 서버 앱만을 위해 운영되기 때문입니다. 하지만 저희는 블록체인 노드인 동시에 게이머의 시스템에서 돌아가는 앱을 만들고 있기 때문에 모든 게이머에게 이런 라이브러리들을 따로 설치하라고 요구하는 건 어려웠습니다.&lt;/p>
&lt;p>그래서 생각한 것이 게임 클라이언트 내에 RocksDB가 의존하는 라이브러리들도 함께 넣어 배포하는 것이었습니다. 하지만 별도의 수정 없이 가이드대로 RocksDB를 동적 링크 라이브러리 형태로 빌드할 경우, 빌드된 RocksDB 라이브러리에서 게임 클라이언트에 함께 포함된 의존 라이브러리들을 찾지 못하는 문제가 있었습니다.&lt;/p>
&lt;p>이 문제를 해결하기 위해 RocksDB 동적 링크 라이브러리 파일의 &lt;a href="https://en.wikipedia.org/wiki/Rpath">rpath&lt;/a>를 수정하는 방식을 사용했습니다. rpath란 &lt;q>run-time search path&lt;/q>를 가리키는 말로, 라이브러리 파일이나 실행 파일 내에 하드코딩 되어서 &lt;a href="https://en.wikipedia.org/wiki/Dynamic_linker">동적 링킹&lt;/a> &lt;a href="https://ko.wikipedia.org/wiki/%EB%A1%9C%EB%8D%94_(%EC%BB%B4%ED%93%A8%ED%8C%85)">로더&lt;/a>가 해당 파일에서 필요한 라이브러리를 찾기 위한 경로입니다. 처음에는 RocksDB 라이브러리를 빌드할때 rpath를 수정하는 방법을 고려했지만 RocksDB의 빌드 스크립트가 생각보다 복잡해 보였기 때문에 빌드가 완료된 라이브러리 파일의 rpath를 수정하기로 했습니다. 다행히 macOS에서는 &lt;a href="https://www.unix.com/man-page/osx/1/install_name_tool/">&lt;code>install_name_tool&lt;/code>&lt;/a>, Linux에서는 &lt;a href="https://github.com/NixOS/patchelf">&lt;code>patchelf&lt;/code>&lt;/a>라는 툴로 다음과 같이 간단하게 rpath를 현재 RocksDB 라이브러리가 존재하는 디렉터리로 수정할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#888"># macOS&lt;/span>
$ install_name_tool -add-rpath &lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;@loader_path&amp;#39;&lt;/span> librocksdb.dylib
&lt;span style="color:#888"># linux&lt;/span>
$ patchelf --set-rpath &lt;span style="color:#369">$ORIGIN&lt;/span> librocksdb.so
&lt;/code>&lt;/pre>&lt;/div>&lt;p>rpath 수정에 관한 보다 자세한 내용은 제가 참조한 아래 페이지들을 참조하시면 좋을 것 같습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://medium.com/@donblas/fun-with-rpath-otool-and-install-name-tool-e3e41ae86172">Fun with rpath, otool, and install_name_tool&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mindonmind.github.io/notes/linux/change_rpath.html">Change Library Search Path For Binary Files in Linux&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="애플리케이션에서의-데이터베이스-기능-구현">애플리케이션에서의 데이터베이스 기능 구현&lt;/h2>
&lt;p>RocksDB는 흔히 사용되는 &lt;a href="https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84%ED%98%95_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4">관계형 데이터베이스&lt;/a>나 &lt;code>DefaultStore&lt;/code>에서 사용하고 있는 &lt;a href="https://www.litedb.org/">LiteDB&lt;/a>등과는 다르게 비교적 단순한 기능만을 지원합니다. 따라서 앞에서 얘기한 데이터베이스에서는 당연하게 지원하는 기능들도 RocksDB를 사용할 때는 애플리케이션에서 직접 구현을 해야 하는 경우가 종종 있습니다.&lt;/p>
&lt;p>대표적으로 저장된 데이터 열(rows)의 갯수를 세는 기능이 존재하지 않기 때문에, 데이터를 업데이트할 때마다 개수를 따로 저장해 놓거나 매번 데이터를 순회하면서 세는 등 여러 방식을 이용하여 해당 기능을 직접 구현해야 합니다.&lt;/p>
&lt;p>또 다른 예로는 키 검색 기능이 있습니다. RocksDB의 &lt;code>Seek&lt;/code>은 키의 첫머리(prefix)를 입력으로 받아서 해당하는 키의 위치를 찾아줍니다. 일반적인 데이터베이스의 키 검색 기능처럼 첫머리가 일치하는 키만 검색될 거라고 기대하기 쉽지만, 일반적인 데이터베이스에서의 검색보다는 파일의 오프셋을 이동하는 &lt;a href="http://man7.org/linux/man-pages/man2/lseek.2.html">&lt;code>lseek()&lt;/code>&lt;/a>와 좀 더 유사한 기능을 합니다. 따라서 이 기능을 이용해서 키를 순회할 때는 매 키 마다 해당 키의 첫머리가 내가 찾는 부분 문자열과 일치하는지 검사해야 합니다.&lt;/p>
&lt;h2 id="문서를-자세히-보지-않으면-하기-쉬운-실수들">문서를 자세히 보지 않으면 하기 쉬운 실수들&lt;/h2>
&lt;p>RocksDB의 API와 문서화는 기대했던 것에 비해 친절하게 되어있는 편은 아니어서 사용하는 데 약간의 주의가 필요했습니다.&lt;/p>
&lt;p>한 예로 RocksDB는 네임스페이스와 같은 역할을 하는 &lt;a href="https://github.com/facebook/rocksdb/wiki/Column-Families">칼럼 패밀리&lt;/a>(Column Family)가 있습니다. 이 칼럼 패밀리를 데이터베이스에 만들어두면 다음번에 데이터베이스를 사용할 때도 알아서 함께 가져올 것을 기대했지만, 기대와는 달리 데이터베이스를 열 때 &lt;code>ListColumnFamilies&lt;/code>라는 API를 이용해서 데이터베이스내의 모든 칼럼 패밀리를 명시해주지 않으면 예외가 발생하는 문제가 있었습니다.&lt;/p>
&lt;p>또 RocksDB는 문서화에 GitHub의 위키를 이용하는데, 버전별로 문서가 나뉘어있는 등의 정리는 따로 되어 있지 않습니다. 예를 들어 &lt;a href="https://github.com/facebook/rocksdb/wiki/Prefix-Seek">prefix seek&lt;/a>에 대한 문서를 보면 사용법이 변경에 따라 계속 추가되는데, 최신 사용법은 문서의 마지막에 기록되어 있어서 문서의 첫 부분만 볼 경우 예전 사용법대로 사용하기가 쉽습니다.&lt;/p>
&lt;h2 id="바인딩-라이브러리의-문제">바인딩 라이브러리의 문제&lt;/h2>
&lt;p>마지막은 RocksDB의 C# 바인딩 라이브러리인 &lt;a href="https://github.com/warrenfalk/rocksdb-sharp">rocksdb-sharp&lt;/a>에 관한 내용입니다.&lt;/p>
&lt;p>&lt;code>RocksDBStore&lt;/code>코드중 rocksdb-sharp의 &lt;code>RocksDBException&lt;/code> 예외를 잡아서 처리하는 코드가 있습니다. 그런데 일부 플랫폼에서는 이 예외를 처리하는 도중 아래와 같은 엉뚱한 예외가 발생하는 경우가 있었습니다.&lt;/p>
&lt;pre>&lt;code>ExecutionEngineException: String conversion error: Illegal byte sequence encounted in the input.
&lt;/code>&lt;/pre>
&lt;p>코드를 살펴본 결과 이는 rocksdb-sharp에서 RocksDB에서 발생한 에러메시지를 인코딩할 때 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringansi?view=netframework-4.8">&lt;code>Marshal.PtrToStringAnsi()&lt;/code>&lt;/a> 메서드를 사용했기 때문에 발생한 문제였습니다. 저희는 위에서 얘기한 라이브러리 의존성 문제를 해결하기 위해 rocksdb-sharp을 포크해서 사용하고 있었기 때문에 해당 부분에 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringuni?view=netframework-4.8">&lt;code>Marshal.PtrToStringUni()&lt;/code>&lt;/a> 메서드를 사용하도록 변경함으로써 어렵지 않게 해당 문제를 해결할 수 있었습니다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>여러 과정을 거치며 RocksDB를 도입하고 저장공간이나 속도 측면에서 향상을 경험할 수 있었습니다. 자세한 구현은 &lt;a href="https://github.com/planetarium/libplanet/blob/master/Libplanet.RocksDBStore/RocksDBStore.cs">코드&lt;/a>를 통해 확인하실 수 있습니다.&lt;/p>
&lt;p>RocksDBStore 혹은 Libplanet에 대해 더 궁금한 점이 있으시다면 언제든 저희 팀이 상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드 대화방&lt;/a>에 놀러 오세요!&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>이 작업을 진행할 당시, Nine Chronicles은 아직 소수의 테스트 플레이어를 대상으로 인스톨러 없이 간소하게 배포할 때였기 때문에, 이런 접근을 하게 되었습니다. 그러나 최근에는 인스톨러를 포함하여 배포하게 되면서 다른 접근도 가능하게 되었습니다. 기회가 된다면 이후 스낵에 다른 접근을 소개하도록 하겠습니다. &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></content><author><name>이승훈</name><uri>https://github.com/earlbread</uri><email>seunghun@planetariumhq.com</email></author></entry><entry><title>Libplanet 게임잼</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/03/libplanet-gamejam/" title="Libplanet 게임잼"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/03/libplanet-gamejam/" hreflang="en" title="Libplanet Game Jam"/><id>https://snack.planetarium.dev/kor/2020/03/libplanet-gamejam/</id><published>2020-03-19T00:00:00+00:00</published><updated>2020-03-19T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요, 플라네타리움의 게임 클라이언트 프로그래머인 송승걸입니다. 이번 시간에는 플라네타리움에서 열렸던 사내 &lt;a href="https://en.wikipedia.org/wiki/Game_jam">게임잼&lt;/a>에 대해 제가 느꼈던 점을 나눠보고자 합니다.&lt;/p>
&lt;p>플라네타리움에선 저희가 자체 제작한 블록체인 게임 라이브러리인 &lt;a href="https://github.com/planetarium/libplanet">Libplanet&lt;/a>을 사용해 게임을 만들고 있습니다. Libplanet은 현재 주로 &lt;a href="https://unity.com/">Unity&lt;/a>에서 사용하는 것을 상정하고 개발 중이기 때문에, 엔진 내에서의 사용성을 위해 Unity용 &lt;a href="https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B0%9C%EB%B0%9C_%ED%82%A4%ED%8A%B8">SDK&lt;/a>를 제작하기로 했습니다. 이를 위해 Unity에서 Libplanet을 사용하는 조그마한 예시 프로젝트를 만들어 작업에 도움을 받기 위해 플라네타리움 사내 게임잼을 개최했습니다.&lt;/p>
&lt;p>2~3명이 한 조를 이뤄 게임 개발을 할 것을 상정하고 개최일까지 2일의 시간을 두고 게임 기획안을 생각해봤고, 그동안 블록체인 기술을 적용해볼 멋진 게임 기획안이 5개나 제시되었습니다. 저는 &lt;a href="https://github.com/limebell">고찬혁&lt;/a> 님과 한 조가 되어 오목 게임을 만들기로 했습니다. 2명의 플레이어가 대국하게 하려고 세션 개념, 즉 여러분들이 익히 알고 계신 게임의 &lt;strong>방&lt;/strong> 개념을 Libplanet의 액션(&lt;code>Action&lt;/code>)과 상태(state) 개념을 사용해 구현했습니다.&lt;/p>
&lt;figure>
&lt;img src="screenshot.png"
alt="저희가 만든 오목 게임의 멋진 모습입니다!"/> &lt;figcaption>
&lt;p>저희가 만든 오목 게임의 멋진 모습입니다!&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>우선 대표적인 상태들과 이를 변경시키는 액션들을 소개해 드리겠습니다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>SessionState&lt;/code>: 세션의 정보를 저장합니다. 세션 안의 플레이어 정보인 &lt;code>AgentState&lt;/code>의 리스트와 세션을 구분할 수 있는 고유한 키(방 제목 개념)가 존재하고, 당연하게도 이 상태를 접근할 수 있도록 하는 주소(Address)도 있습니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>AgentState&lt;/code>: 플레이어의 계정 정보를 저장합니다. 이곳엔 플레이어의 정보(대표적으로 전적)와 주소가 있습니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>PlayerState&lt;/code>: 플레이어가 게임 내에서 사용하는 돌들의 정보를 저장합니다. 오목판 내의 돌의 좌표 정보가 저장됩니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>JoinSession&lt;/code>: 사용자가 입력한 키를 가진 세션에 참가하는 액션입니다. 입력한 키를 가진 세션이 없다면 그 키를 가진 세션을 만듭니다. 이를 통해 &lt;code>SessionState&lt;/code>를 변화시킵니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>PlaceAction&lt;/code>: 바둑돌을 오목판 위에 올려두는 액션입니다. 이를 통해 &lt;code>PlayerState&lt;/code>의 돌 정보를 변화시킵니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ResignAction&lt;/code>: 플레이어가 항복하는 액션입니다. 두 플레이어의 &lt;code>AgentState&lt;/code>를 모두 변화시키는데, 항복한 플레이어에 패배 기록을 함과 동시에 승리한 플레이어에게 승리 기록을 합니다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>자세한 내부 구현이나, 코드를 보고 싶으시다면 &lt;a href="https://github.com/planetarium/planet-omok">Github 저장소&lt;/a>를 둘러보세요!&lt;/p>
&lt;p>결국, Libplanet을 사용한 블록체인 게임 개발의 관건은 결국 이러한 상태와 액션을 어떻게 다루는지에 달려 있다고 생각합니다. 액션은 상태를 변화시키고, 게임 로직에서 상태를 사용해 게임이 동작하는 것이죠. 게임잼 전엔 플라네타리움과 함께 한 지 얼마 되지 않아 액션을 직접 만들어 보지 못했지만, 이번 기회에 일반화된 세션 개념을 고찬혁 님과 함께 구현해보니 액션과 상태의 의미와 일반적인 사용법에 익숙해져 여러모로 좋은 시간이었습니다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>게임잼이니만큼 간단한 예제로써 사용하기 적합한 게임으로 클리커 게임인 Planet Clicker의 &lt;a href="https://github.com/planetarium/planet-clicker">GitHub 저장소&lt;/a>를 둘러보시면서 간단한 액션과 상태 구조를 둘러보시는 건 어떠신가요? 더 자세한 용법이나 질문이 있으시다면 언제든 플라네타리움 팀원이 상주한 &lt;a href="https://discord.gg/planetarium">디스코드 서버&lt;/a>로 놀러 와주세요!&lt;/p></content><author><name>송승걸</name><uri>https://github.com/unengine</uri><email>ssg@planetariumhq.com</email></author></entry><entry><title>게임 개발자, Libplanet을 처음 만났을 때 😂</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/02/hi-libpalnet-i-am-game-developer/" title="게임 개발자, Libplanet을 처음 만났을 때 😂"/><id>https://snack.planetarium.dev/kor/2020/02/hi-libpalnet-i-am-game-developer/</id><published>2020-02-26T00:00:00+00:00</published><updated>2020-02-26T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 플라네타리움에서 게임을 만들고 있는 현승민입니다. 이번 글에서는 일반적인 게임의 &lt;dfn>클라이언트–서버&lt;/dfn> 구조가 아닌 Libplanet을 활용하여 &lt;dfn>&lt;abbr title="peer-to-peer">P2P&lt;/abbr>&lt;/dfn> 구조를 적용하는 방법을 찾아가는 이야기를 소개해드릴게요. 아래의 내용은 전적으로 경험에 기반한 내용이라는 것을 고려해 주세요.&lt;/p>
&lt;p>먼저 &lt;em>클라이언트–서버&lt;/em> 구조에 관해서 이야기해 볼게요. 저는 대부분 프로젝트에서 클라이언트–서버 구조로 개발했어요. 당연하게도 통신을 위해서 프로토콜을 작성했는데, 이 프로토콜은 웹 통신과 비슷하게 디자인했어요. 클라이언트 측에서 요청을 만들어 서버에 넘기면 서버 측에서 응답을 만들어서 클라이언트로 돌려주는 구조이죠. 요청은 주로 유저가 입력한 값을 포함했고, 응답은 프로토콜의 성패 정보를 담는 에러 코드와 요청에 의해 영향을 받은 상태 값(이하 &lt;dfn>변경점&lt;/dfn>)을 포함했어요. (골드를 사용하는 구매 요청에 대한 응답에 구매 후 남은 골드량을 포함하는 등) 물론 클라이언트 측에서 예측 가능한 변경점은 응답에 포함하지 않아도 되었죠.&lt;/p>
&lt;p>다음은 지금 제가 개발하는 환경인 &lt;em>P2P&lt;/em> 구조를 살펴볼게요. Libplanet에서는 위에서 언급한 프로토콜을 &lt;code>IAction&lt;/code> 인터페이스를 구현한 클래스(이하 &lt;dfn>액션&lt;/dfn>)로 작성해요. 클라이언트에서 액션을 만들어 노드에 넘기면 노드는 액션들을 모아서 트랜잭션을 만들고, 트랜잭션들을 모아서 블록을 만들어요. 이 과정에서 각 액션의 &lt;code>Render&lt;/code>(이하 &lt;dfn>렌더&lt;/dfn>)와 &lt;code>Unrender&lt;/code>(이하 &lt;dfn>언렌더&lt;/dfn>) 이벤트가 발생하는데, 이를 통해서 클라이언트 측은 &lt;em>액션이 반영되었다&lt;/em>거나 &lt;em>그 액션이 취소(롤백)되었다&lt;/em>는 상태를 알 수 있는 구조이죠.&lt;/p>
&lt;p>언뜻 비슷한 구조로 보일 수 있지만, 클라이언트–서버에서는 요청과 응답이 분리되어 있어서 응답이 요청의 정보(성패, 실패했다면 그 자세한 이유)는 물론 변경점까지 포함될 수 있는데, P2P에서는 요청(액션) 하나만 존재하고 요청(액션)의 정보(렌더 혹은 언렌더 여부, 이마저도 알려면 노드가 멈추지 않는 조건을 만족해야 함)만 알 수 있다는 차이가 있어요. 대신에 각 액션의 렌더, 언렌더 단계에서는 해당 &lt;em>액션의 전후 상태&lt;/em>를 알 수 있도록 인터페이스를 제공하고 있어요.&lt;/p>
&lt;p>위의 내용들은 제게 한 가지 고민을 만들어 주었어요.&lt;/p>
&lt;blockquote>
&lt;p>변경점은 어떻게 알 수 있을까?&lt;/p>
&lt;/blockquote>
&lt;p>캐릭터 인벤토리에 아이템을 하나 추가해주는 액션을 수행했을 때, 인벤토리 전부를 다시 그리는 것은 피하고 싶었거든요.&lt;/p>
&lt;h3 id="1-액션의-렌더-전후-상태값-비교하기">1. 액션의 렌더 전후 상태값 비교하기&lt;/h3>
&lt;p>처음 생각한 방식은 액션의 렌더 전과 후의 상태 값을 비교해서 변경점을 뽑아 내는 방법이었어요. 하지만, 블록에 직렬화되어 있는 정보를 역직렬화와 캐스팅을 통해서 상태 값 A와 B로 만들어 내고, 그 둘을 비교하는 과정을 매 렌더·언렌더 단계에서 수행하는 것이 성능에 무리가 생길 것이라는 걱정이 생겼어요. 상태 값 A와 B는 이미 덩치가 컸고, 앞으로 더 커질 여지가 다분했기 때문이었죠.&lt;/p>
&lt;h3 id="2-변경점을-각-액션에-포함-시키기">2. 변경점을 각 액션에 포함 시키기&lt;/h3>
&lt;p>이 방법이면 기존 구조를 변경하지 않는 선에서 목표를 완수할 수 있겠다는 생각으로 액션들을 척척 작성해가고 있었어요. 모든 것이 원하는 대로 잘 돌아가는 줄로만 알고 있었던 어느 날, 이제까지의 테스트가 싱글 노드에서 진행되었고 멀티 노드 환경에서는 문제가 생길 거라는 것을 알게 되었죠. 그 이유는 다음과 같았어요.&lt;/p>
&lt;p>네트워크에 참여하는 모든 노드가 특정 액션을 처리하는데, 이를 다른 노드가 처리해서 전파 받더라도 두 처리 결과가 동일할 수 있도록 보장하는 역할을 &lt;code>IAction.PlainValue&lt;/code> 속성과 &lt;code>IAction.LoadPlainValue()&lt;/code> 메서드가 해요. 싱글 노드에서는 얼렁뚱땅 되는 것 처럼 보였어도 멀티 노드에서 잘 되려면 액션의 다른 곳이 아니라 해당 속성에 포함시켜야 되는 것을 깨달은 것이죠. 그렇다고 진짜 포함시키면 (저는 진짜 그냥 단순히 포함시켜 봤어요) &lt;code>InvalidTxSignatureException&lt;/code> 예외가 발생해요. 이것은 액션의 상태값이 바뀔 때 발생하는데, 당연한 것이 변경점은 액션을 만들 때는 비어있고 액션이 렌더된 이후에 채워지기 때문이죠. 이 과정에서 &lt;em>액션의 상태값은 바뀌지 않도록 작성한다&lt;/em>는 깨달음을 얻었어요.&lt;/p>
&lt;p>그렇다면 액션을 만들 때 &lt;em>예측 가능한 변경점&lt;/em>을 포함시키면 되지 않을까 생각했어요. 이것은 클라이언트가 만들어준 값을 노드가 믿는 구조가 되기 때문에 해킹에 용이해서 3초 만에 머리 속에서 지웠죠. 하지만 그 &lt;em>예측 가능한 변경점&lt;/em>을 액션 내에서 검증할 수 있다면 가능하겠다는 생각이 드네요!? 그래서 엔진팀에 문의해 봤더니 엔진에서 제공하는 &lt;code>IRandom&lt;/code> 인터페이스가 완전히 공정하기 때문에 &lt;em>예측 가능한 변경점&lt;/em>은 존재하지 않는다는 감동만이 남았네요. 감동.&lt;/p>
&lt;h3 id="3-변경점을-각-액션이-변경시키는-대상의-상태-값이하-대상-상태-값에-포함-시키기">3. 변경점을 각 액션이 변경시키는 대상의 상태 값(이하 대상 상태 값)에 포함 시키기&lt;/h3>
&lt;p>이 방법도 괜찮아 보였어요. 액션의 변경점을 대상 상태 값에 포함시키면 구조 수정 없이 확장 만으로 목표를 완수할 수 있지 않을까 하는 기대를 갖고 액션들을 척척 작성해 가고 있었어요. 대상 상태 값에는 각 액션의 변경점들이 쌓이기 시작했고, 클라이언트는 특정 액션의 렌더 단계에서 대상 상태 값에 쌓여 있는 변경점을 참조하는 방법을 사용했죠. 이미 한 번 계산한 변경점을 다시 계산할 필요가 없어졌고, 변경점의 참조 타이밍도 문맥상 안전해서 클라이언트 개발이 순조로웠어요. 하지만 문제는 생기기 마련이었죠.&lt;/p>
&lt;blockquote>
&lt;p>대상 상태 값에 쌓이는 특정 액션에 대한 변경점의 생명 주기는 어떻게 관리할 것인가?&lt;/p>
&lt;/blockquote>
&lt;p>상태 값의 변경은 액션을 통해서만 이루어지는 특성상, 더 이상 필요가 없는 변경점을 제거하기 위해서는 별도의 액션으로 처리해야 했어요. A액션의 변경점을 쌓아두기 위해 대상 상태 값을 변경했는데, 이미 사용해서 쌓아둘 필요가 없는 변경점을 대상 상태 값에서 제거하기 위해 B액션을 사용할 때, 그 변경점은 다시 대상 상태 값에 담겨야 하는가? 네, 로직에 예외가 생기더라고요. 이 안은 보류했어요.&lt;/p>
&lt;hr>
&lt;p>이 글을 작성하는 동안에도 Libplanet은 꾸준히 강력해졌어요. 액션의 실행 단계에서 확보되는 &lt;code>IActionContext&lt;/code>형 인자는 액션의 상태값과 무관하게 모든 노드에서 같은 결과를 결정적으로 확보할 수 있도록 &lt;code>IRandom&lt;/code> 인터페이스를 제공하고 있어요. 유니티에서 제공하는 랜덤 객체는 모든 노드에서 같은 결과를 얻을 수 없지만, &lt;code>IRandom&lt;/code> 인터페이스는 이를 보장해주고 있어요. 다시 2번의 접근이 가능하겠다는 각이 보이죠?&lt;/p>
&lt;p>다음 글에서는 &lt;code>IRandom&lt;/code> 인터페이스를 파해치고, 아름다운 클라이언트 환경을 어떻게 만들어 내는지 이야기해 볼게요.&lt;/p></content><author><name>현승민</name><uri>https://github.com/boscohyun</uri><email>seungmin@planetariumhq.com</email></author></entry><entry><title>태국에서만 2562년으로 가는 소프트웨어?</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/02/thai-in-2562/" title="태국에서만 2562년으로 가는 소프트웨어?"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/02/thai-in-2562/" hreflang="en" title="Software from Year 2562 Emerges in Thailand?"/><id>https://snack.planetarium.dev/kor/2020/02/thai-in-2562/</id><published>2020-02-25T00:00:00+00:00</published><updated>2020-02-25T00:00:00+00:00</updated><content type="html">&lt;h2 id="미래에서-온-손님">미래에서 온 손님&lt;/h2>
&lt;p>작년 12월에 저희는 마침내 첫 번째 알파테스트를 진행했고, 감사하게도 세계 각지에서 많은 분이 참여해 주셨습니다. 이는 팀에게 있어 굉장한 기회인 동시에 도전이기도 했습니다. 당연하게 크고 작은 문제가 있었는데요. 그중 저희를 난처하게 만들었던 문제 중 하나는 IBD였습니다.&lt;/p>
&lt;p>&lt;abbr title="initial block download">IBD&lt;/abbr>란 게임을 켰을 때 네트워크의 다른 피어들로부터 그동안 쌓인 블록들을 내려받아 최신 상태로 동기화하는 단계인데요. 아무래도 세계 각지에서 참여하시다 보니 네트워크 지연 등의 문제로 인해 시간이 오래 걸리거나 이상 종료되는 경우가 종종 있었습니다.&lt;/p>
&lt;p>그런데 그중에서도 특이한 증상을 보고한 사용자가 있었습니다. 당시 저희가 겪던 다른 문제들과 다르게 가장 첫 번째 블록을 내려받고 나서 이후 블록을 받을 수 없다는 것이었습니다.&lt;/p>
&lt;figure>
&lt;img src="1.png"
alt="사용자로부터 받은 스크린숏"/> &lt;figcaption>
&lt;p>사용자로부터 받은 스크린숏&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>저희는 이 사용자가 보내 준 스크린숏을 확인하고 한 가지 이상한 점을 깨달았습니다. 날짜가 2019년이 아닌 2562년으로 적혀있던 것이었는데요. 그래서 저희는 한가지 가설을 세웠습니다. 모종의 이유로 파일 시스템이 고장이 나 있어서 블록 헤더의 해시가 잘못 계산되고 있다는 것이죠.&lt;/p>
&lt;p>이를 검증하기 위해 저희는 양해를 구하고 원격 데스크톱을 통해 문제가 발생한 시스템을 직접 조사하기로 했습니다.&lt;/p>
&lt;h2 id="날짜가-잘못되지-않았다">날짜가 잘못되지 않았다&lt;/h2>
&lt;p>다행히 해당 문제를 겪고 있던 사용자는 접속을 흔쾌히 허락해주셨습니다. 스크린숏으로 확인한 것처럼 여전히 날짜는 2562년이었습니다. 일단 가장 먼저 시간을 맞추기 위해 제어판을 열었습니다. 대부분의 현대적인 운영체제가 그렇듯이 Windows도 네트워크를 통해 시간을 동기화하는 기능이 있습니다. 그러나 이렇게 시간을 다시 동기화해도 제어판과 시스템의 날짜는 2562년으로 변함없었고 마지막 동기화 시각도 연도만이 다를 뿐 날짜, 시간이 모두 제가 사용하고 있는 시스템과 다르지 않았습니다.&lt;/p>
&lt;p>그런데 문제를 조금 살펴보기로 하고 제어판 이곳저곳을 확인 하던 중 제 눈길을 끄는 화면이 있었습니다.&lt;/p>
&lt;figure>
&lt;img src="2.png"
alt="그레고리안력으로는 2019년이라고 표시되어 있다."/> &lt;figcaption>
&lt;p>그레고리안력으로는 2019년이라고 표시되어 있다.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>저희 개발팀에서 태국어를 읽을 수 있는 사람은 없었지만, &amp;ldquo;Date in Gregorian&amp;quot;을 보니 &amp;ldquo;2562년&amp;quot;은 &amp;ldquo;2019년&amp;quot;의 다른 표현이라는 것을 알아차렸습니다. 그래서 시험 삼아 포맷을 바꾸니 예상대로 2019년 12월 16일이 표시되었고, 혹시나 하는 마음에 게임을 실행해보니 IBD 단계에서 문제없이 잘 실행이 되었습니다.&lt;/p>
&lt;h2 id="불력-佛曆">불력 (佛曆)&lt;/h2>
&lt;p>재현 방법과 실마리를 찾았으니 사용자께는 일단 잠시 지역 설정을 미국으로 해주실 것을 제안드렸고, 감사하게도 그 사용자분은 그 제안을 승낙하셨습니다.&lt;/p>
&lt;p>문제를 재현하기 위해 저희는 로컬 개발 환경에서 운영체제의 지역 설정을 태국으로 변경한 뒤 Libplanet의 단위 테스트를 돌려봤습니다. 아니나 다를까, 몇몇 테스트가 실패하는 것을 확인할 수 있었습니다. 그 가운데 가장 치명적인 문제는 내용상으로는 같은 블록의 해시가 달라지는 현상이었습니다. 살펴보니 해시의 입력을 만드는 과정에 &lt;a href="https://github.com/planetarium/libplanet/blob/82aaba0c37591ebf51207038e8c5c122272ce98b/Libplanet/Blocks/Block.cs#L488">&lt;code>Block&amp;lt;T&amp;gt;.Timestamp&lt;/code> 필드를 직렬화&lt;/a>한 결과가 기대와 달랐습니다. &lt;code>DateTimeOffset.ToString()&lt;/code> 메서드의 동작이 운영체제의 로캘에 영향을 받는 것입니다.&lt;/p>
&lt;p>인도차이나반도에서 불교는 유럽의 기독교와 같은 위치입니다. 그래서 역법에서도 예수 그리스도의 탄신을 기원(epoch)으로 삼는 &lt;a href="https://ko.wikipedia.org/wiki/%EA%B7%B8%EB%A0%88%EA%B3%A0%EB%A6%AC%EB%A0%A5">그레고리력&lt;/a> 대신, 석가모니의 입멸을 기원으로 삼는 &lt;a href="https://en.wikipedia.org/wiki/Buddhist_calendar">불력&lt;/a>(佛曆)이 일반적으로 쓰였다고 합니다. 캄보디아나 라오스 같은 나라들은 이제 서기 연도를 쓰게 바뀌었지만, 태국은 여전히 불력을 양력으로 고친 &lt;a href="https://en.wikipedia.org/wiki/Thai_solar_calendar">타이 태양력&lt;/a>을 쓰고 있습니다. 석가모니 입멸은 기원전 543년으로, 서기 2019년은 타이 태양력으로 2562년이 됩니다.&lt;/p>
&lt;p>이와 같이, 세계에는 문화권에 따라 다양한 역법을 쓰고 있으므로, 사용자 인터페이스를 표시할 때 각 문화권에 알맞는 날짜 형식으로 표시되어야 합니다. 사실 &lt;code>DateTimeOffset.ToString()&lt;/code> 메서드는 이를 위해 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.iformatprovider?view=netstandard-2.0">&lt;code>IFormatProvider&lt;/code>&lt;/a> 객체도 파라미터로 받는 오버로드를 갖고 있습니다. &lt;code>IFormatProvider&lt;/code> 인터페이스를 구현하는 클래스 중에서 가장 많이 쓰이는 것이 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo?view=netstandard-2.0">&lt;code>CultureInfo&lt;/code>&lt;/a>입니다. 이름에서 알 수 있듯, &lt;code>CultureInfo&lt;/code>는 유닉스 계열에서 로캘(locale)이라고 부르는 것과 같은 개념입니다. 아래와 같이, &lt;code>DateTimeOffset.ToString()&lt;/code> 메서드는 파라미터로 어떤 로캘을 설정하느냐에 따라 결과물이 달라집니다.&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff">&lt;code class="language-csharp" data-lang="csharp">&amp;gt; &lt;span style="color:#080;font-weight:bold">using&lt;/span> &lt;span style="color:#b06;font-weight:bold">System.Globalization&lt;/span>;
&amp;gt; &lt;span style="color:#888;font-weight:bold">var&lt;/span> now = DateTimeOffset.Now;
&amp;gt; now.ToString(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;yyyy-MM-ddTHH:mm:ss.ffffffZ&amp;#34;&lt;/span>, &lt;span style="color:#080;font-weight:bold">new&lt;/span> CultureInfo(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;ko-KR&amp;#34;&lt;/span>))
&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;2020-02-13T17:37:16.436163Z&amp;#34;&lt;/span>
&amp;gt; now.ToString(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;yyyy-MM-ddTHH:mm:ss.ffffffZ&amp;#34;&lt;/span>, &lt;span style="color:#080;font-weight:bold">new&lt;/span> CultureInfo(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;th-TH&amp;#34;&lt;/span>))
&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;2563-02-13T17:37:16.436163Z&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>하지만 아무 로캘도 설정하지 않고 해당 파라미터를 생략하면 적당히 그 코드가 실행되는 환경의 로캘을 따라가게 됩니다. 아래 코드는 제가 운영체제의 지역 설정을 한국으로 해뒀을 때의 결과입니다.&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff">&lt;code class="language-csharp" data-lang="csharp">&amp;gt; now.ToString(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;yyyy-MM-ddTHH:mm:ss.ffffffZ&amp;#34;&lt;/span>)
&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;2020-02-13T17:37:16.436163Z&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.datetimeoffset.tostring?view=netstandard-2.0#System_DateTimeOffset_ToString">문서에 따르면, 해당 파라미터가 생략된 오버로드&lt;/a>는 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.currentculture?view=netstandard-2.0">&lt;code>CultureInfo.CurrentCulture&lt;/code>&lt;/a>를 따른다고 합니다. &lt;code>CultureInfo.CurrentCulture&lt;/code> 속성은 이름에서도 알 수 있듯 실행 환경의 로캘을 가르킵니다. 따라서, 실행 환경의 로캘과 무관하게 언제나 결정적인 동작을 원한다면 명시적으로 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.invariantculture?view=netstandard-2.0">&lt;code>CultureInfo.InvariantCulture&lt;/code>&lt;/a>를 지정해야 합니다.&lt;/p>
&lt;p>메서드가 비결정적으로 동작할 수 있음에도 불구하고 해당 파라미터를 생략하면 실행 환경의 로캘을 따르도록 API를 설계한 것은, 아마 저러한 서식(formatting) 연산이 대개 사용자 인터페이스를 그리는 데에 쓰이고, 그렇기 때문에 국제화에 큰 신경을 쓰지 않고 코딩을 해도 자연스럽게 문화권에 알맞은 서식으로 보이도록 하려는 의도일 것입니다. 하지만 저희가 해당 메서드를 쓴 것은 사용자 인터페이스가 아니라, 결정적이어야 하는 암호학적 해시의 입력인 것이 불찰이었습니다.&lt;/p>
&lt;p>원인을 알았으니 &lt;a href="https://github.com/planetarium/libplanet/pull/734">&lt;code>DateTimeOffset.ToString()&lt;/code> 메서드와 마찬가지로 &lt;code>CultureInfo&lt;/code>나 &lt;code>IFormatProvider&lt;/code> 파라미터가 생략된 메서드를 찾아서, 명시적으로 &lt;code>CultureInfo.InvariantCulture&lt;/code>를 지정하도록 패치&lt;/a>하는 것으로 급한 문제는 일단락됐습니다.&lt;/p>
&lt;p>CI에서도 아랍어나 프랑스어, 히브리어 로캘 등에서도 단위 테스트를 실행하도록 보강하기도 했습니다. 유럽에는 소수점 표시를 점(&lt;code>.&lt;/code>)이 아니라 쉼표(&lt;code>,&lt;/code>)로 하는 나라도 많고, 중동에는 오른쪽에서 왼쪽으로 글을 쓰기도 하므로, 저희에게 다소 생소하게 느껴지는 언어권을 일부러 고른 것입니다.&lt;/p>
&lt;p>또, 앞으로 비슷한 실수는 얼마든지 일어날 수 있기 때문에, 실행 환경의 로캘에 따라 동작이 달라지는 코드를 찾아주는 &lt;a href="https://github.com/planetarium/libplanet/pull/737">정적 분석도 도입&lt;/a>하였습니다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>앞서 언급한 것처럼 암호학적 해시를 계산하는 함수에 서식 같은 비결정적인 동작이 예상되는 API를 사용하는 것은 장기적으로 좋은 결정은 아닙니다. 일반적으로 문자열은 이러한 서식이 많이 적용되기 때문에 자료형 차원에서 피하는 것이 안전합니다.&lt;/p>
&lt;p>하지만 아쉽게도 저희는 이 문제를 테스트 중간에 발견하였고, 해시 방식을 바꾸는 것은 이전 데이터의 호환성을 깨는 결정이었기 때문에 아직 대대적인 수정은 하지 못했습니다. 하지만 Libplanet 릴리스 1.0 전에는 이러한 부분을 수정할 예정입니다.&lt;/p></content><author><name>홍민희</name><uri>https://github.com/dahlia</uri><email>hong.minhee@planetariumhq.com</email></author><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>쿠버네티스로 P2P 게임 테스트하기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/02/k8s-1/" title="쿠버네티스로 P2P 게임 테스트하기"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/02/k8s-1/" hreflang="en" title="Testing P2P Game with Kubernetes"/><id>https://snack.planetarium.dev/kor/2020/02/k8s-1/</id><published>2020-02-20T00:00:00+00:00</published><updated>2020-02-20T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요, &lt;a href="https://planetariumhq.com">플라네타리움&lt;/a>에서 &lt;a href="https://libplanet.io">Libplanet&lt;/a>을 개발하고 있는 문성원입니다. 작년 12월 16일부터 2주일간, 저희가 만들고 있는 완전 탈중앙 MMORPG인 &lt;a href="https://nine-chronicles.com">나인 크로니클&lt;/a>의 알파 테스트가 있었는데요. 오늘은 그 준비를 위해 &lt;a href="https://kubernetes.io/">쿠버네티스&lt;/a>(Kubernetes)에 헤드리스 게임을 배포한 경험을 공유해보려고 합니다.&lt;/p>
&lt;h2 id="어떤-게-필요한가요">어떤 게 필요한가요?&lt;/h2>
&lt;p>Libplanet으로 개발된 게임은 블록체인 노드라고 할 수 있는데, 이는 나인 크로니클도 마찬가지입니다. 즉 모든 게임 클라이언트는 그 자체로 일반적인 게임 서버와 비슷한 역할(데이터 저장, 판정)을 온전히 수행할 수 있습니다. 이러한 P2P 환경에서 게임 환경과 최대한 유사하게 테스트하기 위해서는, 이러한 게임 클라이언트를 동시에 많이 실행하여 테스트할 필요가 있었습니다.&lt;/p>
&lt;h2 id="구체적인-희망-사항">구체적인 희망 사항&lt;/h2>
&lt;ul>
&lt;li>(많은 소프트웨어가 그렇듯이) 테스트 중인 게임 역시 필요에 따라 업데이트를 해야 할 때가 있습니다. 이때 실행된 모든 클라이언트를 돌면서 직접 업데이트하는 것은 그리 좋은 전략이 아닙니다.&lt;/li>
&lt;li>한두 개를 켜서 실행하는 것은 개발자 개인이 쉽게 할 수 있는 일이지만, 우리는 그것보다 많은 게임 클라이언트를 테스트하고 싶습니다.&lt;/li>
&lt;li>게임을 실행하긴 하지만, 많은 게임 클라이언트를 동시에 띄우는 것이기 때문에 각 게임 클라이언트의 화면을 보는 것은 그렇게 중요한 사항이 아닙니다. 즉 아무런 UI 없이 &lt;a href="https://en.wikipedia.org/wiki/Headless_software">헤드리스&lt;/a>(headless)로 실행해도 괜찮습니다.&lt;/li>
&lt;/ul>
&lt;h2 id="도커docker">도커(Docker)&lt;/h2>
&lt;p>이런 사항을 만족하기 위해서는 여러 개의 프로세스를 동시에 실행하고 관리해야 했는데, 이때 사용한 솔루션이 &lt;a href="https://docker.com">도커&lt;/a>(Docker)입니다. 도커는 리눅스 응용 프로그램을 실행환경째로 컨테이너화하여 실행하기 위해 많이 사용하는 솔루션입니다. 나인 크로니클은 첫 출시에서 리눅스를 주요 플랫폼으로 고려하고 있진 않지만, Unity를 사용해서 게임 개발을 하다보니 비교적 쉽게 리눅스용 빌드를 뽑을 수 있었고 (헤드리스 테스트 노드에선 크게 중요치 않은) UI 버그를 제외하면 동작도 크게 다르진 않았습니다.&lt;/p>
&lt;h2 id="쿠버네티스kubernetes">쿠버네티스(Kubernetes)&lt;/h2>
&lt;p>도커를 사용해서 게임 빌드를 어디서나 쉽게 돌릴 수 있게 컨테이너로 만들었지만 이걸로 끝은 아니었습니다. 저희의 목표는 어디까지나 많은 클라이언트를 손쉽게 실행/종료/업데이트하며 테스트 환경을 유지하는 것이니까요. 이를 위해서는 도커만으로는 부족했습니다.&lt;/p>
&lt;p>가장 먼저 떠오른 방법은 &lt;abbr title="Elastic Container Service">&lt;a href="https://aws.amazon.com/ko/ecs/">ECS&lt;/a>&lt;/abbr>와 같이 클라우드 공급자가 제공하는 실행 환경이었습니다. 이런 실행 환경들은 복잡한 워크플로우를 효율적으로 설정할 수 있게 디자인되어있지만, 바꾸어보면 설정이 복잡하며 테스트 환경에서만 사용한다면 많은 기능을 사용하지 않을 것이라는 생각이 들었습니다. 또한 특정 클라우드 공급자에 종속되는 테스트 환경이 이후 이전 작업등에 부담이 될 것 같기도 했고요.&lt;/p>
&lt;figure>
&lt;img src="comparison.png"
alt="AWS 컨테이너 오케스트레이션 비교"/> &lt;figcaption>
&lt;p>AWS 컨테이너 오케스트레이션 비교&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>그래서 떠올린 대안이 쿠버네티스였습니다. 쿠버네티스는 저희가 ECS 같은 서비스를 통해서 하고 싶은 일을 공급자 중립적(Provider Agonistic)으로 할 수 있는 오픈소스 프로젝트입니다. 여러 종류의 복잡한 컨테이너를 손쉽게 띄우고 내리는 기능을 컨테이너 오케스트레이션이라고 하는데, 저희는 거의 같은 종류의 컨테이너(게임)를 여러 개 띄우고 싶은 것뿐이니 설정은 그리 복잡하지 않았습니다.&lt;/p>
&lt;h2 id="다음-이야기">다음 이야기&lt;/h2>
&lt;p>적다 보니 이야기가 많이 길어졌네요. 다음 시간에는 테스트를 위해 쿠버네티스를 어떻게 설정하고 클라우드 상에 배치하고 있는지 구체적인 절차에 대해 살펴보도록 하겠습니다.&lt;/p></content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>Libplanet 0.8 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/02/libplanet-0.8/" title="Libplanet 0.8 릴리스"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/02/libplanet-0.8/" hreflang="en" title="Libplanet 0.8 Released"/><id>https://snack.planetarium.dev/kor/2020/02/libplanet-0.8/</id><published>2020-02-05T00:00:00+00:00</published><updated>2020-02-05T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요.
저희 팀은 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>의 여덟 번째 마이너 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.8.0">0.8 버전&lt;/a>을
릴리스했습니다.&lt;/p>
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때,
그러한 게임들이 매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는
공용 라이브러리입니다.&lt;/p>
&lt;p>거의 세 달 만의 새 버전인 만큼, 0.8 버전에서는 저장소 최적화를 비롯한 많은
개선이 있었습니다.
이 글에서는 0.8 버전의 주요 변경 사항들에 대해 다루겠습니다.&lt;/p>
&lt;h2 id="제너시스-블록-상정">제너시스 블록 상정&lt;/h2>
&lt;p>&lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code>는 이제 특정한 제너시스 블록을 상정하게 되었습니다.
이는 Libplanet으로 만든 여러 게임들이 서로 별개의 네트워크를 구성함에도,
Libplanet이 일종의 메타프로토콜로 동작하기에 엉뚱한 네트워크에 접속 시도를
하는 등의 실수를 방지하기 위해서 입니다.&lt;/p>
&lt;p>&lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Blockchain.BlockChain-1.html#Libplanet_Blockchain_BlockChain_1__ctor_Libplanet_Blockchain_Policies_IBlockPolicy__0__Libplanet_Store_IStore_Libplanet_Blocks_Block__0__">&lt;code>BlockChain&amp;lt;T&amp;gt;()&lt;/code> 생성자&lt;/a>는 &lt;code>Block&amp;lt;T&amp;gt;&lt;/code> 객체를 인자로 받으며,
해당 블록이 가장 첫 블록이 됩니다. 만약 &lt;code>IStore&lt;/code>에 들어있는 제너시스 블록과
&lt;code>BlockChain&amp;lt;T&amp;gt;()&lt;/code> 생성자가 기대하는 제너시스 블록이 일치하지 않을 경우
&lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Blocks.InvalidGenesisBlockException.html">&lt;code>InvalidGenesisBlockException&lt;/code>&lt;/a>이 일어나게
됩니다.&lt;/p>
&lt;p>현재는 생성자가 제너시스 &lt;code>Block&amp;lt;T&amp;gt;&lt;/code> 객체를 통째로 받지만,
&lt;a href="https://github.com/planetarium/libplanet/pull/769">다음 버전에는 제너시스 블록 해시만 받고 실제 블록 내용은 네트워크의 다른
노드한테 받을 수도 있게 개선될 예정입니다.&lt;/a>&lt;/p>
&lt;h2 id="defaultstoredefaultstore--litedbstore">&lt;a href="https://docs.libplanet.io/master/api/Libplanet.Store.DefaultStore.html">&lt;code>DefaultStore&lt;/code>&lt;/a> ← &lt;code>LiteDBStore&lt;/code>&lt;/h2>
&lt;p>내장 &lt;code>IStore&lt;/code> 구현이었던 &lt;code>LiteDBStore&lt;/code>가 사라지고 그 자리를
&lt;a href="https://docs.libplanet.io/master/api/Libplanet.Store.DefaultStore.html">&lt;code>DefaultStore&lt;/code>&lt;/a>가 대체했습니다.&lt;/p>
&lt;p>이름이 바뀐 까닭은 더이상 LiteDB 파일 하나가 아닌,
여러 포맷이 섞인 파일들을 담는 디렉터리에 저장되게 바뀌었기 때문입니다.&lt;/p>
&lt;p>또한, 1.0.0 릴리스 전까지 실험을 거듭하여 저장소 최적화를 할 예정으로,
이름에서 구현 세부 사항을 제거하는 의도도 있었습니다.&lt;/p>
&lt;p>그 외에도 저장 공간을 줄이기 위한 &lt;a href="https://docs.libplanet.io/master/api/Libplanet.Store.DefaultStore.html#Libplanet_Store_DefaultStore__ctor_System_String_System_Boolean_System_Boolean_System_Int32_System_Int32_System_Int32_System_Int32_System_Boolean_System_Boolean_">&lt;code>DefaultStore()&lt;/code> 생성자&lt;/a>에는
&lt;code>compress&lt;/code> 옵션이 생겼습니다. 이번 버전에서는 아직 기본적으로 꺼져 있지만,
다음 버전에서는 기본값이 &lt;code>true&lt;/code>로 바뀔 예정입니다.&lt;/p>
&lt;h2 id="icryptobackendicryptobackend">&lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Crypto.ICryptoBackend.html">&lt;code>ICryptoBackend&lt;/code>&lt;/a>&lt;/h2>
&lt;p>Libplanet은 다양한 플랫폼에서도 쓸 수 있도록,
순수 C#으로 작성된 암호학 라이브러리인 &lt;a href="http://www.bouncycastle.org/csharp/">Bouncy Castle&lt;/a>을 써왔습니다.
그러나 순수 C# 구현은 이식성에서는 큰 장점이 되지만,
성능에서는 오히려 페널티로 작용합니다.&lt;/p>
&lt;p>새 버전에서는 이식성과 성능 중 어느 쪽을 취할지 게임 제작자가 고를 수 있도록,
&lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Crypto.ICryptoBackend.html">&lt;code>ICryptoBackend&lt;/code>&lt;/a>라는 추상화 계층이 추가됐습니다.
기본 구현인 &lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Crypto.DefaultCryptoBackend.html">&lt;code>DefaultCryptoBackend&lt;/code>&lt;/a>는 여전히
내부적으로 Bouncy Castle에 의존하지만,
게임 제작자는 게임의 타깃 플랫폼에 따라 적절히 &lt;code>ICryptoBackend&lt;/code> 인터페이스를
구현하여 성능 이점을 누릴 수 있습니다.&lt;/p>
&lt;p>예를 들어, Libplanet이 &lt;code>ICryptoBackend&lt;/code>를 구현한 &lt;code>MyCryptoBackend&lt;/code> 클래스를
쓰게 하고 싶다면,
아래와 같이 &lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Crypto.CryptoConfig.html#Libplanet_Crypto_CryptoConfig_CryptoBackend">&lt;code>CryptoConfig.CryptoBackend&lt;/code> 속성&lt;/a>를
덮어씌우면 됩니다.&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#fff">&lt;code class="language-csharp" data-lang="csharp">CryptoConfig.CryptoBackend = &lt;span style="color:#080;font-weight:bold">new&lt;/span> MyCryptoBackend();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>저희 팀에서 만드는 게임인 &lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>에서는 비트코인 프로젝트에서 공개한
&lt;a href="https://github.com/bitcoin-core/secp256k1">secp256k1&lt;/a> C 라이브러리를 호출하는 &lt;code>ICryptoBackend&lt;/code> 인터페이스를 구현하여
게임 성능을 개선하기도 했습니다.&lt;/p>
&lt;h2 id="라우팅-테이블-개선">라우팅 테이블 개선&lt;/h2>
&lt;p>Libplanet은 &lt;a href="https://snack.planetarium.dev/kor/2019/09/kademlia/">분산 해시 테이블 방식&lt;/a>을 적용하여 다른 피어와 통신하기 때문에
라우팅 테이블의 자신과 연결된 피어들의 정보를 저장합니다.&lt;/p>
&lt;p>기존에는 이 라우팅 테이블에 해당 피어와 가장 최근에 통신한 시점만을
저장하고 있었는데,
추가로 해당 피어와의 통신 딜레이를 추가하여 사용자가 네트워크 환경에 대한
자세한 정보를 알 수 있도록 하였습니다.&lt;/p>
&lt;p>개발자들은 새로 추가된
&lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Net.Swarm-1.html#Libplanet_Net_Swarm_1_CheckAllPeersAsync_System_Nullable_TimeSpan__CancellationToken_">&lt;code>Swarm&amp;lt;T&amp;gt;.CheckAllPeersAsync()&lt;/code> 메서드&lt;/a>를
이용하여 라우팅 테이블에 저장된 피어들을 갱신할 수 있고,
&lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Net.Swarm-1.html#Libplanet_Net_Swarm_1_Peers">&lt;code>Swarm&amp;lt;T&amp;gt;.Peers&lt;/code> 속성&lt;/a>에 접근해 Libplanet의 외부에서도 현재
자신의 라우팅 테이블에 들어있는 피어들을 확인할 수 있게 되었습니다.&lt;/p>
&lt;h2 id="블록-구조-및-직렬화-방식의-변경">블록 구조 및 직렬화 방식의 변경&lt;/h2>
&lt;p>블록체인을 구성하는 요소인 블록은 크게 트랜잭션을 제외한 메타데이터 부분과
트랜잭션, 이렇게 두 부분로 나눌 수 있습니다.&lt;/p>
&lt;p>많은 블록체인 프로젝트들이 그렇듯 저희 역시 여기서 트랜잭션을 뺀
부분을 블록 헤더로 정의하였고,
기존에 블록 해시로만 수행하던 연산들을 좀더 풍부한 정보를 담은 블록 헤더를
이용해 수행하게 바꾸어 기존보다 효율적인 연산을 할 수 있게 되었습니다.&lt;/p>
&lt;p>더불어, 블록과 트랜잭션을 직렬화할 때 필드 키를 짧게 줄이고,
비어있는 필드는 아예 배제함으로써 직렬화된 표현을 경량화했습니다.&lt;/p>
&lt;h2 id="문서-개선">문서 개선&lt;/h2>
&lt;p>라이브러리 자체의 변경은 아니지만, &lt;a href="https://docs.libplanet.io/0.8.0/">문서 웹사이트&lt;/a>의 디자인에 개선이
있었고, 문성원 님이 작성하신 새로운 &lt;a href="https://docs.libplanet.io/0.8.0/articles/overview.html">개요&lt;/a> 문서도 추가됐습니다.&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>그 밖에도, 세 달 남짓 Libplanet으로 만들고 있는 게임 &lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>의
퍼블릭 테스트를 몇 차례 진행하며 발견한 많은 문제들을 바로잡느라 매우 다양한
변화가 있었습니다. 자세한 것은 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.8.0">전체 변경 내역&lt;/a>에서 확인할 수 있습니다.&lt;/p>
&lt;p>호기심이 생기신 분들은 설치해서 이용해 보시고, 궁금한 점이 있으시다면 저희 팀이
상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드&lt;/a>에 놀러오세요!&lt;/p></content><author><name>고찬혁</name><uri>https://github.com/limebell</uri><email>lime@planetariumhq.com</email></author><author><name>홍민희</name><uri>https://github.com/dahlia</uri><email>hong.minhee@planetariumhq.com</email></author></entry><entry><title>Libplanet 0.7 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/11/libplanet-0.7/" title="Libplanet 0.7 릴리스"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/11/libplanet-0.7/" hreflang="en" title="Libplanet 0.7 Released"/><id>https://snack.planetarium.dev/kor/2019/11/libplanet-0.7/</id><published>2019-11-11T00:00:00+00:00</published><updated>2019-11-11T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 저희 팀은 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>의 일곱 번째 마이너 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.7.0">0.7 버전&lt;/a>을 릴리스했습니다.&lt;/p>
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때, 그러한 게임들이 매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는 공용 라이브러리입니다.&lt;/p>
&lt;p>0.7 버전에서는 Libplanet의 안정성 및 성능 개선과 더불어 다양한 사용성 개선이 있었습니다. 이 글에서는 0.7 버전의 주요 변경 사항들에 대해 다루겠습니다.&lt;/p>
&lt;h2 id="액션-및-상태의-타입-제한">액션 및 상태의 타입 제한&lt;/h2>
&lt;p>기존 Libplanet에서 상태 및 액션의 속성은 &lt;code>object&lt;/code> 타입으로 표현되고 저장할 때는 알아서 &lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/binary-serialization">.NET의 바이너리 직렬화&lt;/a> 포맷으로 직렬화되었습니다. 이 방식은 .NET 객체를 그대로 직렬화할 수 있으므로 Libplanet을 쓰는 쪽에서도 만드는 쪽에서도 생각할 게 적다는 장점이 있습니다. 하지만 저희 팀은 이 방식을 처음 도입했을 때부터 여러 한계를 인식한 채 한시적으로 사용할 것을 의도했는데, 그 한계는 다음과 같은 것들이 있습니다.&lt;/p>
&lt;ul>
&lt;li>직렬화 역직렬화가 구체적으로 이뤄지는 방식이 암시적입니다. 타입의 구현이 달라지면 직렬화되는 포맷에도 영향이 가지만 구체적으로 어떤 변화가 일어나는지 짐작하기 어렵습니다.&lt;/li>
&lt;li>과거에는 모양이 달랐던 타입의 값이 직렬화되어 블록체인에 저장된 뒤, 현재 타입으로 역직렬화를 시도했을 때 런타임 오류가 나거나 의도한 것과 다른 의미로 해석될 수 있습니다.&lt;/li>
&lt;li>팀에서 정의한 타입이라면 &lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/version-tolerant-serialization">VTS&lt;/a> 같은 기법을 도입할 수도 있지만, 실수로 팀에서 만든 어셈블리가 아닌 패키지 등을 통해 가져다 쓴 타입이 섞여서 직렬화된 경우 나중에 해당 타입의 내부 표현이 달라져서 직렬화 형식이 바뀌어도 대응하기가 어렵습니다.&lt;/li>
&lt;li>직렬화된 결과를 .NET이 아닌 플랫폼에서 해석하기 어려울뿐더러, 같은 .NET 플랫폼이라도 직렬화된 타입을 포함한 어셈블리를 공유하지 않으면 역직렬화는 어렵습니다. 따라서 &lt;a href="https://github.com/planetarium/libplanet-explorer">Libplanet Explorer&lt;/a>나 &lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/version-tolerant-serialization">Libplanet Explorer Frontend&lt;/a> 같은 앱에서 액션의 속성이나 특정 시점의 상태를 사람이 보기 쉽게 표시하기 힘듭니다.&lt;/li>
&lt;/ul>
&lt;p>그래서 이번 버전부터는 상태 및 액션의 속성은 &lt;a href="https://github.com/planetarium/bencodex.net">Bencodex&lt;/a>의 &lt;a href="https://github.com/planetarium/bencodex.net/blob/0.2.0/Bencodex/Types/IValue.cs">&lt;code>IValue&lt;/code>&lt;/a> 타입을 통해서 표현하도록 바뀌었습니다. 따라서 게임 내부에서 정의해서 쓰는 타입들을 &lt;code>IValue&lt;/code> 형식으로 변환하는 코드, 그리고 &lt;code>IValue&lt;/code> 형식으로 표현된 것을 다시 게임 내 타입들로 해석하는 코드를 명시적으로 써야 합니다. 조금 귀찮아진 것도 사실이지만, 대신 직렬화하려는 타입의 내부 표현이 바뀌어도 직렬화 혹은 역직렬화 메서드에 해당 변경에 따른 처리 로직을 추가할 수 있게 되었고, 각기 다른 버전 사이의 호환을 좀 더 구현하기 쉽게 되었습니다.&lt;/p>
&lt;h2 id="blockchaint의-ireadonlylistt-구현-제거">&lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code>의 &lt;code>IReadOnlyList&amp;lt;T&amp;gt;&lt;/code> 구현 제거&lt;/h2>
&lt;p>이전 버전까지 &lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code> 클래스는 &lt;code>IReadOnlyList&amp;lt;T&amp;gt;&lt;/code> 인터페이스를 구현하고 있었고, 그에 따라 &lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code> 객체에 직접 &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/">LINQ&lt;/a> 확장 메서드들을 사용할 수 있었습니다. LINQ 확장 메서드는 선형적인 객체를 다룰 때 다양한 편리를 제공하지만, 사용 방법에 따라 상당한 성능상의 차이를 가져올 수 있습니다. 예를 들어 &lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code> 객체에 10,000개의 블록이 있을 때 LINQ의 &lt;code>.Last()&lt;/code> 메서드를 사용하여 10,000 번째 블록을 가져오고자 한다면 마지막 블록만을 저장소에서 바로 가져온다고 생각하기 쉽습니다. 하지만 실제로는 &lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code>의 첫 블록부터 마지막 블록까지 조회하며 각 블록에 대해 스토리지에 저장된 내용을 메모리에 올리고 해석하는 작업이 이뤄지게 됩니다. 저장된 블록이 적을 때는 이런 점이 큰 문제가 되지 않지만, 블록이 많아질수록 이런 사용방식이 큰 성능 문제로 이어질 수 있습니다.&lt;/p>
&lt;p>이번 버전부터는 &lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code> 클래스에서 &lt;code>IReadOnlyList&amp;lt;T&amp;gt;&lt;/code> 구현을 아예 제거함으로써 LINQ 확장 메서드를 잘못 사용해 생길 수 있는 문제를 방지하도록 했습니다. 대신 &lt;a href="https://docs.libplanet.io/0.7.0/api/Libplanet.Blockchain.BlockChain-1.html#Libplanet_Blockchain_BlockChain_1_Contains_Libplanet_Blocks_Block__0__">&lt;code>BlockChain&amp;lt;T&amp;gt;.Contains()&lt;/code>&lt;/a> 같이 자주 쓰이는 연산은 효율적인 구현을 직접 제공하기로 했습니다.&lt;/p>
&lt;h2 id="개인키를-안전하게-저장할-수-있는-키-저장소-구현">개인키를 안전하게 저장할 수 있는 키 저장소 구현&lt;/h2>
&lt;p>이번 버전에서는 개인키를 암호화하여 안전하게 보호할 수 있도록 키 저장소가 추가되었습니다. 키 저장소 내 각각의 키 파일은 &lt;a href="https://docs.libplanet.io/0.7.0/api/Libplanet.KeyStore.ProtectedPrivateKey.html">&lt;code>ProtectedPrivateKey&lt;/code>&lt;/a> 클래스로 표현되며, 사용자가 입력한 암호(passphrase)로 개인키를 암호화 하여 저장할 수 있습니다. 또한, &lt;a href="https://docs.libplanet.io/0.7.0/api/Libplanet.KeyStore.ProtectedPrivateKey.html#Libplanet_KeyStore_ProtectedPrivateKey_WriteJson_Stream_System_Nullable_Guid___">&lt;code>ProtectedPrivateKey.WriteJson()&lt;/code>&lt;/a> 메서드를 이용해 &lt;a href="https://en.wikipedia.org/wiki/Ethereum">이더리움&lt;/a>의 &lt;a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3 Secret Storage Definition&lt;/a>에 따라 JSON 형식으로 저장할 수 있습니다. 추후 키 저장소 디렉터리를 통합적으로 관리하는 기능도 추가될 예정입니다.&lt;/p>
&lt;p>현재 &lt;a href="https://en.wikipedia.org/wiki/Key_derivation_function">키 유도함수&lt;/a>는 &lt;a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2&lt;/a>와 &lt;a href="https://en.wikipedia.org/wiki/Scrypt">Scrypt&lt;/a>가 구현되어있고, &lt;a href="https://ko.wikipedia.org/wiki/%EA%B3%A0%EA%B8%89_%EC%95%94%ED%98%B8%ED%99%94_%ED%91%9C%EC%A4%80">AES&lt;/a>-128-&lt;a href="https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A1%9D_%EC%95%94%ED%98%B8_%EC%9A%B4%EC%9A%A9_%EB%B0%A9%EC%8B%9D#%EC%B9%B4%EC%9A%B4%ED%84%B0_(CTR)">CTR&lt;/a> 암호화 알고리즘을 지원하고 있습니다. 이 중 Scrypt 구현은 &lt;a href="https://github.com/minhoryang">minhoryang&lt;/a> 님의 &lt;a href="https://github.com/planetarium/libplanet/pull/654">기여&lt;/a>로 추가되었습니다. 🎉&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>이번 버전에는 &lt;a href="https://hacktoberfest.digitalocean.com/">Hacktoberfest&lt;/a> 행사로 많은 분의 기여가 있었습니다. 해당 행사에 관한 내용은 문성원 님이 작성하신 &lt;a href="/kor/2019/11/looking-back-at-hacktoberfest/">Hacktoberfest를 돌아보며&lt;/a>에서 자세히 보실 수 있고, 그 외 이번 버전의 모든 변경 사항은 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.7.0">전체 변경 내용&lt;/a>에서 확인하실 수 있습니다.&lt;/p>
&lt;p>이번 변경 사항이나 Libplanet에 대해 궁금한 점이 있으시다면 언제든 저희 팀이 상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드 대화방&lt;/a>에 방문해 주세요!&lt;/p></content><author><name>이승훈</name><uri>https://github.com/earlbread</uri><email>seunghun@planetariumhq.com</email></author></entry><entry><title>Hacktoberfest를 돌아보며</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/11/looking-back-at-hacktoberfest/" title="Hacktoberfest를 돌아보며"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/11/looking-back-at-hacktoberfest/" hreflang="en" title="Looking Back on Hacktoberfest"/><id>https://snack.planetarium.dev/kor/2019/11/looking-back-at-hacktoberfest/</id><published>2019-11-08T00:00:00+00:00</published><updated>2019-11-08T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 오늘은 저희 &lt;a href="https://planetariumhq.com">플라네타리움&lt;/a> 팀이 지난 10월 한 달간 &lt;a href="https://hacktoberfest.digitalocean.com/">Hacktoberfest&lt;/a>에 참가하여 받은 기여들을 소개해보려 합니다.&lt;/p>
&lt;h1 id="둘러보기">둘러보기&lt;/h1>
&lt;p>Hacktoberfest를 맞아 저희는 36개의 이슈를 준비했고, 그중 15개의 이슈가 기여를 통해 처리되었습니다.&lt;/p>
&lt;figure>
&lt;img src="1.png"
alt="처리된 이슈들"/> &lt;figcaption>
&lt;p>처리된 이슈들&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>한 달간 기여를 받아보니 다음과 같은 재밌는 사실도 알게 되었습니다.&lt;/p>
&lt;ul>
&lt;li>절반 정도의 기여가 월초에 집중되었습니다. 초반 스퍼트가 중요해 보이네요. 🏃&lt;/li>
&lt;li>대부분의 이슈가 초심자를 위한 이슈(&lt;code>label:&amp;quot;good first issue&amp;quot;&lt;/code>)였습니다.&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/">Libplanet&lt;/a>, &lt;a href="https://github.com/planetarium/libplanet-explorer/">Libplanet Explorer&lt;/a>, &lt;a href="https://github.com/planetarium/libplanet-explorer-frontend/">Libplanet Explorer Frontend&lt;/a> 3개 프로젝트가 고르게 기여를 받았습니다.&lt;/li>
&lt;/ul>
&lt;h1 id="기억에-남는-기여들">기억에 남는 기여들&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/MaxStalker">@MaxStalker&lt;/a> 님이 작업해 주신 &lt;a href="https://github.com/planetarium/libplanet-explorer-frontend/issues/37">Auto refresh when block mined&lt;/a>는 코멘트 숫자에서도 알 수 있듯이, 꽤 난항을 겪은 이슈였습니다. Libplanet Explorer Frontend는 특성상 GraphQL 백엔드인 Libplanet Explorer가 있어야 하는데, 저희가 준비한 GraphQL 백엔드가 계속 내려가는 문제가 있어서 꽤 기다리셔야 했거든요. 😢 서비스가 정상화된 뒤에도 &lt;a href="https://discord.gg/planetarium">저희 디스코드 서버&lt;/a>에서 이런저런 트러블슈팅을 함께 해가면서 기여를 마무리해 주신 @MaxStalker 님께 이 자리를 빌려 감사의 말씀을 전합니다. 🙇&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/RozzaysRed">@RozzaysRed&lt;/a> 님은 Hackoberfest 기간 중, &lt;em>hacktoberfest&lt;/em> 레이블이 붙어있는 이슈뿐만 아니라 그렇지 않은 이슈들에도 &lt;a href="https://github.com/issues?q=assignee%3ARozzaysRed+is%3Aclosed">많은 기여&lt;/a>를 해주셨습니다. 이럴 줄 알았으면 저희가 &lt;em>hacktoberfest&lt;/em> 레이블을 좀 더 빨리, 많이 붙여둘 걸 그랬네요. 😊&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet/issues/555">Rename “maxValue” parameters in IRandom.Next() methods&lt;/a> 이슈에서는 &lt;a href="https://github.com/pBouillon">@pBouillon&lt;/a> 님께 기여뿐 아니라 적당한 파라미터 명(&lt;code>lowerBound&lt;/code>, &lt;code>upperBound&lt;/code>)을 제안받기도 했습니다. 💬&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="마치며">마치며&lt;/h1>
&lt;p>그 밖에도 Hacktoberfest 기간 중 저희가 준비한 프로젝트에 관심과 기여를 보내 주신 모든 분들께 다시 한번 감사의 말씀 드립니다.&lt;/p>
&lt;p>Hacktoberfest는 끝났지만, 저희는 언제나 여러분을 기다리고 있습니다. 혹시 저희가 풀고 있는 문제에 관심이 있거나 함께 하고 싶으신 분은 언제라도 &lt;a href="https://discord.gg/planetarium">디스코드 대화방&lt;/a>에서 알려주세요!&lt;/p></content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>Libplanet 0.6 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/10/libplanet-0.6/" title="Libplanet 0.6 릴리스"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/10/libplanet-0.6/" hreflang="en" title="Libplanet 0.6 Released"/><id>https://snack.planetarium.dev/kor/2019/10/libplanet-0.6/</id><published>2019-10-04T00:00:00+00:00</published><updated>2019-10-04T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 저희 팀은 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>의 여섯 번째 마이너 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.6.0">0.6 버전&lt;/a>을 릴리스했습니다.&lt;/p>
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때, 그러한 게임들이 매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는 공용 라이브러리입니다.&lt;/p>
&lt;p>0.6 버전에서는 Libplanet의 네트워크 구성과 관련한 큰 변화가 있었고, 잘 관측되지 않았던 버그들을 다수 수정했습니다. 이 글에서는 0.6 버전의 주요 변경 사항들에 대해 다루겠습니다.&lt;/p>
&lt;h2 id="kademlia-분산-해시-테이블-적용">Kademlia 분산 해시 테이블 적용&lt;/h2>
&lt;p>기존의 Libplanet에서는 각 피어가 네트워크상의 모든 피어들을 전부 관리했습니다. 생성한 데이터를 전파하는 블록체인의 특성상 이와 같은 방법은 네트워크에 적은 수의 피어들이 접속해 있다면 그럭저럭 작동하지만, 피어의 수가 많을 때는 네트워크 통신 문제가 생기게 됩니다.&lt;/p>
&lt;p>위 문제를 해결하여 더욱 많은 피어들을 관리하기 위해 분산 해시 테이블 기법의 하나인 Kademlia 프로토콜이 적용되었습니다. Kademlia 분산 해시 테이블의 작동 원리가 궁금하시다면 &lt;cite>&lt;a href="https://snack.planetarium.dev/kor/2019/09/kademlia/">Kademlia 분산 해시 테이블 적용기&lt;/a>&lt;/cite>를 참고해 주세요.&lt;/p>
&lt;h2 id="트랜잭션-전파-방식-변경">트랜잭션 전파 방식 변경&lt;/h2>
&lt;p>어떤 클라이언트가 트랜잭션을 생성했을 때 해당 클라이언트는 자신의 라우팅 테이블이 가진 있는 피어들에 해당 데이터를 전파하고, 이를 통해 블록체인 네트워크상의 모든 피어가 동기화됩니다.&lt;/p>
&lt;p>기존 Libplanet은 트랜잭션을 일정 주기마다 전파하는 방식으로 작동했었고, 각 피어가 네트워크 위에 존재하는 모든 피어들의 정보를 갖고 있었기 때문에 한 번의 전파로 모든 피어가 동기화되었습니다. 그러나 Kademlia 분산 해시 테이블이 적용되면서 한 번의 전파만으로는 모든 피어가 동기화되었음을 보장할 수 없게 되었습니다. 각 피어는 전파받은 데이터를 다시 전파하는 방식으로 네트워크에 퍼트리는데, 트랜잭션 전파가 일정 주기마다 실행되었기에 운이 나쁘다면 네트워크가 동기화되는 데 많은 시간이 소요되었습니다.&lt;/p>
&lt;p>따라서 이 패치에서는 트랜잭션을 전파받았을 때 즉시 전파하게 로직을 수정하여 네트워크 동기화 과정이 오래 지연되는 것을 방지하였습니다.&lt;/p>
&lt;h2 id="한-블록-내-트랜잭션들의-실행-순서-보장">한 블록 내 트랜잭션들의 실행 순서 보장&lt;/h2>
&lt;p>한 블록 안에 여러 개의 트랜잭션이 포함될 때, 모든 클라이언트에서 같은 순서로 액션이 실행하는 것을 보장해 주어야 합니다. 그러면서도 블록을 마이닝 하기 전까지는 그 실행 순서를 예측할 수 없어야 합니다.&lt;/p>
&lt;p>이번 업데이트에서는 위의 조건을 만족하기 위해 블록의 트랜잭션을 담을 때, 블록의 &lt;code>Hash&lt;/code> 값과 트랜잭션의 &lt;code>Id&lt;/code>를 이용해 순서를 정렬하여 모든 클라이언트에서 액션이 같은 순서로 실행되는 것이 보장될 수 있게 하였습니다.&lt;/p>
&lt;h2 id="비동기-블록-마이닝">비동기 블록 마이닝&lt;/h2>
&lt;p>Libplanet은 &lt;a href="https://ko.wikipedia.org/wiki/%EC%9E%91%EC%97%85_%EC%A6%9D%EB%AA%85_%EC%8B%9C%EC%8A%A4%ED%85%9C">작업 증명 시스템&lt;/a>을 기반으로 블록을 합의하기 때문에, 블록을 생성하는 마이닝 과정에서 다량의 CPU 자원을 소모합니다. 기존에는 블록의 &lt;code>Nonce&lt;/code>를 찾는 &lt;code>Hashcash.Answer()&lt;/code> 함수가 동기 함수였기 때문에 실행 중인 스레드가 차단되었고, 작업을 도중에 중단하는 것이 어려웠습니다.&lt;/p>
&lt;p>이번 패치를 통해 &lt;code>BlockChain&amp;lt;T&amp;gt;.Mine()&lt;/code>이 비동기 함수가 되어 사용자가 &lt;code>CancellationToken&lt;/code>을 주어 원하는 시점에 중단시킬 수 있게 되었습니다. 또한 마이닝 도중 블록체인의 팁이 변경되었을 때 외부에서 구독 가능한 &lt;code>BlockChain&amp;lt;T&amp;gt;.TipChanged&lt;/code> 이벤트가 불리고, 해당 이벤트가 발생할 시 진행하던 마이닝이 중단되게 됩니다.&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>그 외의 여러 가지 변경 사항은 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.6.0">전체 변경 내용&lt;/a>에서 확인하실 수 있습니다.&lt;/p>
&lt;p>이번 변경 사항이나 Libplanet에 대해 궁금한 점이 있으시다면 언제든 저희 팀이 상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드 대화방&lt;/a>에 방문해 주세요!&lt;/p></content><author><name>고찬혁</name><uri>https://github.com/limebell</uri><email>lime@planetariumhq.com</email></author></entry><entry><title>저희와 함께 Hacktoberfest에 참가해봅시다!</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/09/hacktoberfest/" title="저희와 함께 Hacktoberfest에 참가해봅시다!"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/09/hacktoberfest/" hreflang="en" title="Join Us for Hacktoberfest!"/><id>https://snack.planetarium.dev/kor/2019/09/hacktoberfest/</id><published>2019-09-26T00:00:00+00:00</published><updated>2019-09-26T00:00:00+00:00</updated><content type="html">&lt;div style="display: block; margin: auto; margin-top: 30px; width: 500px;">&lt;a href="https://hacktoberfest.digitalocean.com/">&lt;img src="hacktoberfest.png" width="500">&lt;/a>&lt;/div>
&lt;p>안녕하세요, 어느새 Hacktoberfest의 달, 10월이 찾아왔습니다.&lt;/p>
&lt;p>혹시 &lt;dfn>&lt;a href="https://hacktoberfest.digitalocean.com/">Hacktoberfest&lt;/a>&lt;/dfn>라는 행사를 들어보셨나요? Hacktoberfest는 10월 1일부터 31일까지 한 달 동안 진행되는 오픈 소스 행사입니다. 전 세계 모두에게 열려있으며 10월 내라면 언제든지 참여할 수 있고, 깃허브 공개 저장소에 4개의 풀 리퀘스트를 제출하면 됩니다.&lt;/p>
&lt;p>4개의 풀 리퀘스트를 올리면 DigitalOcean 같은 주최측에서 제공하는 티셔츠 혹은 스티커를 받으실 수 있습니다.&lt;/p>
&lt;p>저희 팀도 올해 &lt;a href="https://github.com/planetarium/libplanet/issues?q=label:hacktoberfest+is:open+is:issue">Libplanet&lt;/a> 프로젝트들로 참가합니다!&lt;/p>
&lt;h2 id="그래서-어떻게-시작해야-하죠">그래서 어떻게 시작해야 하죠?&lt;/h2>
&lt;p>Hacktoberfest에 참가하고 싶지만 정작 어떤 걸로 풀 리퀘스트를 올려서 기여해야 할지 막막하실 것입니다.&lt;/p>
&lt;p>그래서 Hacktoberfest를 통해 새롭게 기여하려는 분들께 시작하기 적합한 이슈에 &lt;q>&lt;em>hacktoberfest&lt;/em>&lt;/q> 라벨을 달아 두었습니다.
그러니 여러분은 &lt;q>hacktoberfest&lt;/q> 라벨이 달려있는 이슈들 중 마음에 드는 것을 고르시고 작업을 시작한다는 댓글을 남기시면 됩니다.
어떤 이슈들이 있는지 저희 프로젝트인 &lt;a href="https://github.com/planetarium/libplanet/issues?q=label:hacktoberfest+is:open+is:issue">Libplanet&lt;/a>, &lt;a href="https://github.com/planetarium/libplanet-explorer/issues?q=label:hacktoberfest+is:open+is:issue">Libplanet Explorer&lt;/a>, &lt;a href="https://github.com/planetarium/libplanet-explorer-frontend/issues?q=label:hacktoberfest+is:open+is:issue">Libplanet Explorer Frontend&lt;/a>의 이슈 트래커를 살펴봐 주세요.&lt;/p>
&lt;figure>
&lt;img src="hacktoberfest-issues.png"
alt="hacktoberfest 라벨이 붙은 이슈들" width="500"/> &lt;figcaption>
&lt;p>&lt;q>hacktoberfest&lt;/q> 라벨이 붙은 이슈들&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>작업을 시작하게 되면 댓글이나 채팅을 통해 다른 오픈 소스 기여자들과 이야기를 나누시게 될 텐데요.
만약 오픈 소스 프로젝트에 참여하는 것이 처음이어도 메인테이너들을 비롯한 다른 기여자들이 도와줄 것입니다.&lt;/p>
&lt;p>상품 수령이나 기타 정보 같은 자세한 내용은 &lt;a href="https://hacktoberfest.digitalocean.com/">Hacktoberfest 공식 사이트&lt;/a>를 참고하시면 좋을 것 같습니다.&lt;/p>
&lt;h2 id="질문-및-대화">질문 및 대화&lt;/h2>
&lt;p>Hacktoberfest 기간 동안 기여하면서 궁금한 점이 생기거나 어려움을 겪고 계시다면 댓글로 이야기 나눌 수도 있지만 저희 팀이 상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드 대화방&lt;/a>에 들어오셔서 같이 소통하면 좋을 것 같습니다! 물론 Hacktoberfest가 끝난 후라도 언제든 환영입니다.&lt;/p></content><author><name>이도건</name><uri>https://github.com/moreal</uri><email>dogeon@planetariumhq.com</email></author></entry><entry><title>Kademlia 분산 해시 테이블 적용기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/09/kademlia/" title="Kademlia 분산 해시 테이블 적용기"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/09/kademlia/" hreflang="en" title="Applying Kademlia Distributed Hash Table to Libplanet"/><id>https://snack.planetarium.dev/kor/2019/09/kademlia/</id><published>2019-09-17T00:00:00+00:00</published><updated>2019-09-17T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 플라네타리움 개발팀의 고찬혁입니다. 이번에는 분산 P2P 네트워크를 효율적으로 구성하기 위한 &lt;a href="https://ko.wikipedia.org/wiki/%EB%B6%84%EC%82%B0_%ED%95%B4%EC%8B%9C_%ED%85%8C%EC%9D%B4%EB%B8%94">분산 해시 테이블&lt;/a> 기법 중 하나인 &lt;a href="https://en.wikipedia.org/wiki/Kademlia">Kademlia&lt;/a>가 무엇인지 간단하게 설명드리고, 왜 이를 저희 프로젝트인 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>에 적용하게 되었는지에 대해서 간단히 말해보는 시간을 가지려고 합니다.&lt;/p>
&lt;h2 id="kademlia가-무엇인가요">Kademlia가 무엇인가요?&lt;/h2>
&lt;p>분산 해시 테이블은 데이터를 네트워크 상의 노드들에 분산하여 저장하여 관리하는 기술입니다. 네트워크 상에서 데이터를 찾을 때 그 데이터를 갖고 있는 노드를 찾아 값을 요청하여 각 노드가 받는 부하를 줄이는데 큰 역할을 합니다.&lt;/p>
&lt;p>분산형 해시 테이블을 구현하는 여러 종류의 구현체들은 네트워크 상의 노드들을 각각 다른 방법으로 자신의 라우팅 테이블에 저장합니다. 그렇다면 그 중 Kademlia는 분산 해시 테이블을 어떻게 구현하고 있을까요? 이에 대해 설명하기 앞서서 쉽게 이해하실 수 있게 간단한 예시를 들어보겠습니다. 2008년에 미국에 LA에 거주했던 재미 교포인 김씨의 얘기를 해보죠. 그는 오랜만에 한국에 있는 친구를 만나기 위해 한국을 방문했고, 이제 막 인천 국제 공항에 내렸습니다.&lt;/p>
&lt;blockquote>
&lt;p>친구 집으로 가고 싶은데, 주소만 보고는 어디인지 잘 모르겠는걸.&lt;/p>
&lt;/blockquote>
&lt;p>저런, 김씨가 길을 잃은 것 같네요. 2019년이었다면 스마트폰을 꺼내 주소를 입력해 찾아갔겠지만, 아쉽게도 2008년에는 스마트폰이 많이 보급되지 않아 김씨는 스마트폰을 갖고 있지 않았습니다. 김씨는 가지고 유일한 정보인 주소를 다시 유심히 살펴봅니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>서울특별시 종로구 세종로 1-91번지&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>딱히 특별한 수가 없던 김씨는 우선 서울특별시를 찾아갔습니다. 그리고 그 곳에서 사람들을 잡고 길을 물어보지만, 위 주소를 정확히 알고 있는 사람은 많지 않군요. 김씨는 전략을 바꿔 종로구를 가려면 어떻게 해야 하는지 물어보기 시작합니다. 종로구를 아는 사람은 꽤 많았고, 우여곡절 끝에 종로구에 도착했습니다. 이제 세종로에 대해서 물어볼 차례군요!&lt;/p>
&lt;p>김씨는 이처럼 정확한 위치를 알지 못했지만 점점 범위를 좁혀가며 친구의 집에 도착했는데요, Kademlia를 적용한 네트워크의 각 피어도 이렇게 피어들의 정보를 유지하고, 탐색합니다.&lt;/p>
&lt;p>네트워크 상의 피어들은 가상의 주소를 갖습니다. *&amp;ldquo;서울특별시 종로구 세종로 1-91번지&amp;rdquo;*와 같은 지리적 주소가 아닌 임의로, 혹은 정해진 규칙에 따라 배정된 일련의 바이트들이죠. 거리 개념 역시 실제 피어간에 물리적인 거리가 아닌, 두 피어의 주소값의 &lt;a href="https://ko.wikipedia.org/wiki/%EB%B0%B0%ED%83%80%EC%A0%81_%EB%85%BC%EB%A6%AC%ED%95%A9#%EB%B9%84%ED%8A%B8%EA%B0%84_%EB%B0%B0%ED%83%80%EC%A0%81_%EB%85%BC%EB%A6%AC%ED%95%A9">배타적 논리합&lt;/a>으로 정의합니다.&lt;/p>
&lt;p>Kademlia 프로토콜을 적용한 피어는 자신의 라우팅 테이블에 네트워크 상의 다른 모든 피어들의 정보를 담는 대신, 그 피어들을 위에서 정의한 거리에 따라 분류해 각 거리 범위당 제한된 개수의 피어만 저장합니다. 거리가 최소 2&lt;sup>i&lt;/sup>에서 최대 2&lt;sup>i+1&lt;/sup> 사이의 피어들은 라우팅 테이블의 i번째 행에 저장하는 식으로요. 이렇게 선택적으로 피어들의 정보를 라우팅 테이블에 저장하게 되면 어떤 피어 A의 라우팅 테이블에 피어 B가 포함되어 있지 않더라도, 자신이 알고있는 피어들 중 피어 B와 가장 가까운 피어에 정보를 요청하고, 그 피어는 다시 자신의 라우팅 테이블 내의 피어들 중 가장 근접한 피어에 요청을 하는 작업을 반복하다보면 결국 피어 B를 찾아낼 수 있을 것입니다.&lt;/p>
&lt;h2 id="kademlia를-적용한-이유가-무엇인가요">Kademlia를 적용한 이유가 무엇인가요?&lt;/h2>
&lt;p>서버가 없이 통신하는 P2P 네트워크를 구성하기 위해서는 모든 피어간에 통신이 보장되어야 합니다. 그러나 모든 피어가 서로 직접적으로 연결되어 있어야 하는 것은 아니죠. 여기 세 개의 피어 A, B 그리고 C가 있습니다.&lt;/p>
&lt;p>기존 Libplanet에서는 다음과 같이 네트워크를 구성했죠. 모든 피어가 서로 연결되어 있는 구성이었습니다.&lt;/p>
&lt;figure>
&lt;img src="1.png"
alt="모든 피어가 서로 연결되어 있다."/> &lt;figcaption>
&lt;p>모든 피어가 서로 연결되어 있다.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>그러나 이렇게 네트워크를 구성한다면 네트워크의 규모가 작을 때는 큰 문제가 되지 않지만, 피어의 수가 1000개, 아니면 10000개라면 그 만큼의 업로드를 매 메시지를 네트워크에 전파할 때마다 해야 하기에 많은 부하가 걸리게 됩니다.&lt;/p>
&lt;figure>
&lt;img src="2.png"
alt="과도한 송신량에 과부하가 걸린 피어."/> &lt;figcaption>
&lt;p>과도한 송신량에 과부하가 걸린 피어.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>Kademlia를 이용하여 노드를 탐색해 만든 라우팅 테이블의 각 행에는 자신으로부터 거리가 같은 범위 내에 있는 피어들로 구성될 것입니다. 데이터를 전파할 때 라우팅 테이블의 각 행에서 피어들을 선택하여 메시지를 보내고, 메시지를 받은 피어가 그 메시지를 다시 자신의 라우팅 테이블의 각 행에서 선택한 피어에 보낸다면, 결과적으로 네트워크 상의 모든 피어들은 메시지를 받게 될 것입니다. 이렇게 하면 n개의 피어가 네트워크 상에 존재할 때 한 피어는 log(n)번만 메시지를 보내게 될 것이고, 네트워크 부하가 하나의 피어에 집중되는 것을 막을 수 있겠죠.&lt;/p>
&lt;figure>
&lt;img src="3.png"
alt="메시지를 전파하는 네트워크."/> &lt;figcaption>
&lt;p>메시지를 전파하는 네트워크.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>게임을 운영하는 데 있어 유저들이 실행하는 액션이 빠르게 실행된다는 느낌을 주기 위해서는 그 액션이 포함된 트랜잭션을 담는 블록을 자주 생성해야겠죠. 블록을 자주 생성할수록 마이너가 받는 네트워크 부하량도 커질 것입니다. 그런 만큼 네트워크가 커질 것을 대비해 분산 해시 테이블의 적용이 필요했고, 실제로 규모를 올려서 테스트를 진행했을 때 하나의 피어에 걸리는 네트워크 부하가 감소하는 수확이 있었습니다.&lt;/p>
&lt;p>Kademlia 분산 해시 테이블이나 Libplanet에 대해 더 궁금한 점이 있으시다면 언제든 저희 팀이 상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드 대화방&lt;/a>에 놀러 오세요!&lt;/p></content><author><name>고찬혁</name><uri>https://github.com/limebell</uri><email>lime@planetariumhq.com</email></author></entry><entry><title>Libplanet 0.5 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/09/libplanet-0.5/" title="Libplanet 0.5 릴리스"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/09/libplanet-0.5/" hreflang="en" title="Libplanet 0.5 Released"/><id>https://snack.planetarium.dev/kor/2019/09/libplanet-0.5/</id><published>2019-09-06T00:00:00+00:00</published><updated>2019-09-06T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 저희 팀은 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>의 다섯 번째 마이너 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.5.0">0.5 버전&lt;/a>, 그리고 그 패치 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.5.1">0.5.1&lt;/a> 및 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.5.2">0.5.2&lt;/a> 버전을 릴리스했습니다.&lt;/p>
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때, 그러한 게임들이 매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는 공용 라이브러리입니다.&lt;/p>
&lt;p>0.5 버전에서는 Libplanet과 함께 만들고 있는 게임의 테스트 과정에서 광범위한 성능 및 안정성 개선이 있었습니다. 이 글에서는 그러한 0.5 버전의 주요 변경 사항들에 대해 다루겠습니다.&lt;/p>
&lt;h2 id="abbr-titleinitial-block-downloadibdabbr-속도-개선">&lt;abbr title="Initial Block Download">IBD&lt;/abbr> 속도 개선&lt;/h2>
&lt;p>이전까지의 &lt;a href="https://bitcoin.org/en/glossary/initial-block-download">IBD&lt;/a>(밀린 블록 다운로드)는 블록이 조금만 많이 쌓여도 굉장히 오래 걸리는 작업이었습니다. 블록들을 다운받은 후 최종 상태를 첫 블록에서부터 스스로 연산하여 얻었어야 했었기 때문이죠.&lt;/p>
&lt;p>하지만 신뢰할 수 있는 노드가 있다면 그 노드로부터 미리 연산돼 있는 결과를 받아와 연산에 드는 시간 효과적으로 줄일 수도 있을 것입니다.&lt;/p>
&lt;p>그래서 0.5 버전 부터는 &lt;a href="https://docs.libplanet.io/0.5.0/api/Libplanet.Net.Swarm-1.html#Libplanet_Net_Swarm_1_PreloadAsync_System_IProgress_Libplanet_Net_PreloadState__System_Collections_Immutable_IImmutableSet_Libplanet_Address__System_Threading_CancellationToken_">&lt;code>Swarm&amp;lt;T&amp;gt;.PreloadAsync()&lt;/code>&lt;/a>에 신뢰할 수 있는 노드들을 인자로 넘겨주어 신뢰할 수 있는 노드들로 부터 이미 연산되어 있는 최근 상태 값들을 받아와 저장, 사용할 수도 있게 되었습니다.&lt;/p>
&lt;p>만약 신뢰할 수 있는 노드들이 없거나 다른 이유로 그 과정에 실패했을 때에는 기존과 같이 직접 연산해서 사용합니다.&lt;/p>
&lt;h2 id="irandomnextdouble-제거">&lt;code>IRandom.NextDouble()&lt;/code> 제거&lt;/h2>
&lt;p>&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.double?view=netstandard-2.0#remarks">&lt;code>System.Double&lt;/code>의 .NET Standard 공식 문서&lt;/a>의 일부를 인용하면 다음과 같은 내용을 볼 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>또한, &lt;code>Double&lt;/code> 값의 산술 연산 및 대입 결과는 &lt;code>Double&lt;/code> 타입의 정밀도 유실 때문에 플랫폼에 따라 다소 달라질 수 있습니다. 예를 들어, &lt;code>Double&lt;/code> 값 리터럴을 대입한 결과는 32 비트와 64 비트 버전의 .NET 프레임워크에서 서로 다를 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;p>위와 같이 Double의 산술 연산 및 대입은 결정적이지 않은 결과를 유발할 수 있습니다. 이 때문에 0.5 버전 부터는 &lt;a href="https://github.com/planetarium/libplanet/pull/419">&lt;code>IRandom.NextDouble()&lt;/code>&lt;/a>을 제공하지 않기로 결정하였습니다.&lt;/p>
&lt;p>이에 관한 자세한 내용은 &lt;a href="https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/">이 글&lt;/a>을 참고하시기 바랍니다.&lt;/p>
&lt;h2 id="블록-액션">블록 액션&lt;/h2>
&lt;p>체인을 안전하게 유지하기 위해서는 블록들을 채굴할 마이너들이 필요하고, 그러한 마이너들을 모으고 유지하기 위해 보상을 주어야 할 것입니다.&lt;/p>
&lt;p>기존에는 마이너들에게 보상을 주기 위해선 직접 마이너가 블록에 리워드 액션을 가진 트랜잭션을 스스로 추가해야 했었지만, 이번 버전부터는 매 블록마다 실행되는 &lt;a href="https://docs.libplanet.io/0.5.0/api/Libplanet.Blockchain.Policies.IBlockPolicy-1.html#Libplanet_Blockchain_Policies_IBlockPolicy_1_BlockAction">&lt;code>IBlockPolicy&amp;lt;T&amp;gt;.BlockAction&lt;/code>&lt;/a> 속성이 생겨 이 블록 액션을 통해 마이너에게 보상금을 주는 코드를 구현할 수 있습니다.&lt;/p>
&lt;h2 id="filestore-제거">&lt;code>FileStore&lt;/code> 제거&lt;/h2>
&lt;p>Libplanet은 저장 계층을 간추리기 위해 &lt;a href="https://docs.libplanet.io/0.5.0/api/Libplanet.Store.IStore.html">&lt;code>IStore&lt;/code>&lt;/a>라는 인터페이스와 이를 파일 기반으로 구현한 &lt;a href="https://docs.libplanet.io/0.4.0/api/Libplanet.Store.FileStore.html">&lt;code>FileStore&lt;/code>&lt;/a>를 비롯하여 &lt;a href="https://www.litedb.org/">LiteDB&lt;/a>를 기반으로 구현한 &lt;a href="https://docs.libplanet.io/0.5.0/api/Libplanet.Store.LiteDBStore.html">&lt;code>LiteDBStore&lt;/code>&lt;/a>를 추가적으로 &lt;a href="/kor/2019/07/libplanet-0.4/">0.4&lt;/a> 버전 부터 제공하고 있었습니다. 그러나 &lt;code>FileStore&lt;/code>는 구현이 내부 구현이 간소하다는 장점에도 불구하고 다음과 같은 한계점도 있었습니다.&lt;/p>
&lt;ul>
&lt;li>모든 블록과 트랜잭션 그리고 계정의 매 블록마다의 상태 등이 각기 별도의 파일로 저장되는 방식이었기 때문에, 파일이 너무 많이 생겼습니다.&lt;/li>
&lt;li>별도의 캐시나 버퍼가 없어서 어떤 물리 저장 장치를 쓰느냐에 따라 입출력 성능이 크게 영향을 받았습니다.&lt;/li>
&lt;/ul>
&lt;p>LiteDB를 사용하기 시작하면서 &lt;code>FileStore&lt;/code>의 사용 빈도는 줄어들었고, 그에 비해 &lt;code>FileStore&lt;/code>를 지속적으로 관리하기는 어렵다고 판단, 이번 0.5 버전부터는 &lt;code>FileStore&lt;/code> 구현체를 제공하지 않기로 결정하였습니다.&lt;/p>
&lt;h2 id="좀-더-상세한-프리로드-진행-상황-전달">좀 더 상세한 프리로드 진행 상황 전달&lt;/h2>
&lt;p>위에서 언급했던 IBD 과정을 수행하기 위해서는 &lt;a href="https://docs.libplanet.io/0.5.0/api/Libplanet.Net.Swarm-1.html#Libplanet_Net_Swarm_1_PreloadAsync_System_IProgress_Libplanet_Net_PreloadState__System_Collections_Immutable_IImmutableSet_Libplanet_Address__System_Threading_CancellationToken_">&lt;code>Swarm&amp;lt;T&amp;gt;.PreloadAsync()&lt;/code>&lt;/a> 메서드를 호출 할 수 있습니다. 이 메서드의 인자로 &lt;code>IProgress&amp;lt;BlockDownloadState&amp;gt;&lt;/code>를 전달하면 이를 통해 블록 다운로드 진행 상황을 알 수 있었지만, 블록 다운로드 이후 액션들을 실행하여 (또는 신뢰할 수 있는 노드로부터) 최종 상태를 구하는 작업의 진척 상황은 알려주지 않았습니다.
이로 인해 블록을 모두 다운로드 받은 이후 로딩 메시지에는 &lt;q>100%&lt;/q>라고 보여줌에도 불구하고 여전히 아무런 변화 없이 &lt;q>로딩 중&lt;/q>과 같은 고정된 메시지를 얼마간 동안 보게 된다면, 게임을 플레이하는 유저 입장에서는 기다리는 시간이 매우 지루하게 느껴질 것입니다.&lt;/p>
&lt;p>하지만 0.5 버전부터는 &lt;code>IProgress&amp;lt;BlockDownloadState&amp;gt;&lt;/code> 대신 &lt;code>IProgress&amp;lt;PreloadState&amp;gt;&lt;/code> 타입의 인자를 받음으로써 프리로드 전반의 진행 상황을 세부적으로 전달받을 수 있도록 되었습니다.&lt;/p>
&lt;p>&lt;a href="https://docs.libplanet.io/0.5.0/api/Libplanet.Net.PreloadState.html">&lt;code>PreloadState&lt;/code>&lt;/a>를 상속 받은 &lt;a href="https://docs.libplanet.io/0.5.0/api/Libplanet.Net.BlockDownloadState.html">&lt;code>BlockDownloadState&lt;/code>&lt;/a>, &lt;a href="https://docs.libplanet.io/0.5.0/api/Libplanet.Net.BlockStateDownloadState.html">&lt;code>BlockStateDownloadState&lt;/code>&lt;/a>,
&lt;a href="https://docs.libplanet.io/0.5.0/api/Libplanet.Net.StateReferenceDownloadState.html">&lt;code>StateReferenceDownloadState&lt;/code>&lt;/a>, &lt;a href="https://docs.libplanet.io/0.5.0/api/Libplanet.Net.ActionExecutionState.html">&lt;code>ActionExecutionState&lt;/code>&lt;/a>를 인자로 받은 &lt;code>IProgress&amp;lt;PreloadState&amp;gt;&lt;/code> 객체를 통해 알림으로써 이용자에게 더 자세한 정보를 제공할 수 있습니다.&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>그 외의 여러 가지 변경 사항은 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.5.0">0.5.0&lt;/a> 및 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.5.1">0.5.1&lt;/a>, &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.5.2">0.5.2&lt;/a> 전체 변경 내역에서 확인하실 수 있습니다.&lt;/p>
&lt;p>이번 변경 사항이나 Libplanet에 대해 궁금한 점이 있으시다면 언제든 저희 팀이 상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드 대화방&lt;/a>에 놀러 오세요!&lt;/p></content><author><name>이도건</name><uri>https://github.com/moreal</uri><email>dogeon@planetariumhq.com</email></author></entry><entry><title>파이콘 스프린트에 다녀오다</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/08/pycon-sprint-2019/" title="파이콘 스프린트에 다녀오다"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/08/pycon-sprint-2019/" hreflang="en" title="Libplanet at PyCon 2019 Sprint"/><id>https://snack.planetarium.dev/kor/2019/08/pycon-sprint-2019/</id><published>2019-08-21T00:00:00+00:00</published><updated>2019-08-21T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요 플라네타리움 개발팀에서 &lt;a href="https://github.com/planetarium/libplanet">Libplanet&lt;/a>을 개발하고 있는 이도건입니다!&lt;/p>
&lt;p>지난 8월 15일 부터 8월 16일까지 2일간 열린 &lt;a href="https://archive.pycon.kr/2019/program/sprint">파이콘 2019 스프린트&lt;/a>에
&lt;a href="https://github.com/planetarium/libplanet">Libplanet&lt;/a> 프로젝트의 리더로 저희 팀이 참가했었습니다.
이 글에서는 파이콘 스프린트에서 받았던 기여들에 대해 간략히 이야기 해보고자 합니다.&lt;/p>
&lt;h2 id="기여-소개">기여 소개&lt;/h2>
&lt;p>스프린트에 참여해 주신 분들 덕분에 &lt;a href="https://github.com/planetarium/libplanet">Libplanet&lt;/a> 프로젝트를 비롯하여 &lt;a href="https://github.com/planetarium/libplanet-explorer">Libplanet Explorer&lt;/a> 프로젝트와 &lt;a href="https://github.com/planetarium/libplanet-explorer-frontend">Libplanet Explorer 웹 프론트엔드&lt;/a> 프로젝트에 추가된 기능들이 정말 많습니다!&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet-explorer">Libplanet Explorer&lt;/a>는 Libplanet을 이용한 게임에서 생성된 블록들을 &lt;a href="https://graphql.org/">GraphQL&lt;/a>을 통하여 쉽게 탐색할 수 있도록 도와주는 프로젝트이고
&lt;a href="https://github.com/planetarium/libplanet-explorer-frontend">Libplanet Explorer 웹 프론트엔드&lt;/a>는 이를 브라우저에서 쉽게 볼 수 있게 하기 위한 TypeScript + React 프로젝트입니다.&lt;/p>
&lt;p>&lt;img src="./balloon.jpg" alt="balloon">&lt;/p>
&lt;p>파이콘 준비 위원회 분들께서 PR을 올릴 때마다 풍선을 선물해 주셨는데요.
저 많은 풍선들을 있게 한 기여 받은 PR들 중 일부를 공유해보고자 합니다!&lt;/p>
&lt;h3 id="수상한-블록-다운로드-개수">수상한 블록 다운로드 개수&lt;/h3>
&lt;p>다른 노드로부터 해당 노드가 갖고 있지 않은 블록에 어떤 것이 있는 지에 대한 질의를 받았을 때
일정한 개수로 나누어 블록 해시들을 질의한 노드에게 전달하게 됩니다.&lt;/p>
&lt;p>하지만 블록 해시를 보내줄 때 첫 응답을 제외하고는 기대와는 다르게 하나 적게 전달해 주는 문제가 있었는데요.
이 문제의 해결을 위해 &lt;a href="https://github.com/gurrpi">백대현&lt;/a> 님께서 기여해 주셨습니다.&lt;/p>
&lt;p>이를 통해 원래 기대한 만큼의 블록 해시들을 보내고 받을 수 있게 되었습니다.&lt;/p>
&lt;h3 id="빈-블록-숨기기">빈 블록 숨기기!&lt;/h3>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet">Libplanet&lt;/a>은 &lt;a href="https://en.bitcoin.it/wiki/Proof_of_work">작업 증명(proof of work)&lt;/a> 기반의 가장 긴 체인만을 인정하는 방식을 따르고 있으므로
트랜잭션이 아무것도 들어있지 않더라도 꾸준히 블록을 생성하게 되는데요.
블록 자체보다는 그 안에 들어간 트랜잭션들을 살펴봐야 할 때에는 쿼리 결과에 빈 블록들이 섞여 있어서 거추장스러울 수 있습니다.&lt;/p>
&lt;p>하지만 저희가 관심있는 블록들은 주로 트랜잭션이 들어 있는 블록들이고
이를 위한 옵션을 &lt;a href="https://github.com/hyeguiee">하혜미&lt;/a> 님께서 기여를 통해 추가해 주셨습니다!&lt;/p>
&lt;p>이를 통해서 원한다면 트랜잭션이 포함되어 있는 블록들만 볼 수 있게 되었습니다.&lt;/p>
&lt;h3 id="프론트엔드-도커화">프론트엔드 도커화!&lt;/h3>
&lt;p>도커(&lt;a href="https://docker.io/">Docker&lt;/a>)는 애플리케이션을 컨테이너를 이용하여 쉽게 만들고 배포하고 실행할 수 있도록 도와주는 도구입니다.&lt;/p>
&lt;p>&lt;a href="https://github.com/minhoryang">양민호&lt;/a> 님께서 해주신 기여를 통하여 &lt;a href="https://github.com/planetarium/libplanet-explorer-frontend">Libplanet Explorer 웹 프론트엔드&lt;/a>에 도커파일을 만들어 주신 덕분에
어디든 쉽게 배포하거나 로컬에서 쉽게 돌려볼 수 있는 환경이 마련되었습니다.&lt;/p>
&lt;h3 id="프론트엔드-변경-사항">프론트엔드 변경 사항!&lt;/h3>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet-explorer">Libplanet Explorer&lt;/a>의 변경 사항에 따라 혹은 별개로 프론트엔드에도 여러 기능이 추가되었습니다.&lt;/p>
&lt;p>&lt;a href="https://github.com/AiOO">안기욱&lt;/a> 님과 &lt;a href="https://github.com/kanghyojun">강효준&lt;/a> 님 그리고 &lt;a href="https://github.com/aucch">aucch&lt;/a> 님 의 기여로 이제는 트랜잭션들이 없는
블록들을 필터링하는 옵션, 블록 생성 시간, 난이도 평균 등을 보여줍니다!&lt;/p>
&lt;p>&lt;img src="./frontend-screenshot.png" alt="frontend-screeshot">&lt;/p>
&lt;p>또한 트랜잭션의 세부 사항을 볼 수 있도록 개별 트랜잭션 페이지가 생겼습니다!&lt;/p>
&lt;p>&lt;img src="./frontend-screenshot-transaction.png" alt="frontend-screenshot">&lt;/p>
&lt;h2 id="기여는-언제든지-환영입니다">기여는 언제든지 환영입니다!&lt;/h2>
&lt;p>스프린트 기간이 아니더라도 저희 프로젝트에 대한 질문 혹은 기여는 언제든 환영입니다!
&lt;a href="https://github.com/planetarium/libplanet">GitHub 저장소&lt;/a>로 찾아오셔서 이슈에 코멘트를 남겨주셔도 좋고 &lt;a href="https://discord.gg/wUgwkYW">저희 디스코드 서버&lt;/a>에 오셔서 물어봐주셔도 좋습니다.&lt;/p></content><author><name>이도건</name><uri>https://github.com/moreal</uri><email>dogeon@planetariumhq.com</email></author></entry><entry><title>Unity 테스트 러너 도입기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/07/unity-test-runner/" title="Unity 테스트 러너 도입기"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/07/unity-test-runner/" hreflang="en" title="Experiencing Unity Test Runner"/><id>https://snack.planetarium.dev/kor/2019/07/unity-test-runner/</id><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 플라네타리움 개발팀 양천웅입니다. 오늘은 &lt;a href="https://docs.unity3d.com/Manual/testing-editortestsrunner.html">Unity 테스트 러너&lt;/a> 도입 시도에 대한 경험담을 얘기하려 합니다.&lt;/p>
&lt;h2 id="들어가기-전에">들어가기 전에&lt;/h2>
&lt;p>현재 저는 &lt;a href="https://github.com/planetarium/libplanet.net">Libplanet&lt;/a>과 Unity를 사용해 블록체인 게임 개발을 하고 있습니다. 팀에 합류한 이후 Unity로 게임을 만든다는 얘기가 나왔을 때는 막연히 &amp;lsquo;GUI 프로그래밍 경험이 없는 것도 아니고, 게임도 GUI 프로그래밍하듯이 하면 되겠지'라는 근거 없는 자신감을 가지고 시작했습니다.&lt;br>
처음 프로젝트를 시작했을 때는 일정과 Unity에 대한 이해도가 부족한 상황이라 테스트를 포기하고 작업을 진행했지만, 시간이 지날수록 테스트 도입에 대한 필요성이 커졌고 그때 발견한 것이 Unity 테스트 러너였습니다.&lt;/p>
&lt;p>Unity 테스트 러너는 Unity에서 자체적으로 제공하는 테스트 도구입니다. &lt;a href="https://nunit.org/">NUnit&lt;/a> 기반의 테스트를 작성 후, 플레이 모드와 에디트 모드 각각에 테스트 환경을 구축하여&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> Unity 에디터에서 테스트를 실행할 수 있습니다.&lt;/p>
&lt;h2 id="어셈블리-정의-파일-assembly-definition-files">어셈블리 정의 파일 (assembly definition files)&lt;/h2>
&lt;p>처음 문서를 보며 테스트 스크립트를 만들었는데 문제를 만났습니다. 다른 라이브러리들은 정상적으로 인식이 되는데, 정작 테스트를 해야 하는 게임 코드의 네임스페이스를 인식 못 하는 것이었습니다.
원인은 Unity 에디터 실행 시 자동으로 인식되는 &lt;em>Assembly-CSharp.dll&lt;/em>과 다르게, 테스트 스크립트 안에서는 게임 프로젝트의 스크립트를 인식 못 하기 때문이었습니다.&lt;/p>
&lt;figure>
&lt;img src="tests-asmdef.png"
alt="Tests.asmdef에 의존성을 추가"/> &lt;figcaption>
&lt;p>&lt;em>Tests.asmdef&lt;/em>에 의존성을 추가&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>프로젝트 스크립트를 정의한 어셈블리 정의 파일을 만든 뒤 테스트용으로 정의된 어셈블리 정의 파일&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>에 의존성을 추가해주면 문제가 해결됩니다.&lt;/p>
&lt;p>자세한 내용은 &lt;a href="https://docs.unity3d.com/kr/current/Manual/ScriptCompilationAssemblyDefinitionFiles.html">관련 문서&lt;/a>를 참고해주세요.&lt;/p>
&lt;h2 id="어셈블리-정의-파일의-플랫폼-설정">어셈블리 정의 파일의 플랫폼 설정&lt;/h2>
&lt;p>어셈블리 정의 파일을 생성한 후에도 문제가 있었는데, 에디터에서는 정상적으로 작동하는 서드파티 라이브러리가 프로젝트 빌드 시에 인식이 안 되면서 깨지는 문제였습니다.
라이브러리가 Unity 에디터의 확장 기능을 제공하는 경우가 있는데, 어셈블리 정의 파일이 에디터용 기능을 빌드에 포함하려다 발생하는 문제였습니다.&lt;/p>
&lt;figure>
&lt;img src="unity-platform.png"
alt="허용 플랫폼을 에디터만 체크"/> &lt;figcaption>
&lt;p>허용 플랫폼을 에디터만 체크&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>해결 방법은 간단한데, 해당 라이브러리의 &lt;em>Editor&lt;/em> 폴더 내부에 에디터용 정의 파일을 따로 생성 후, 플랫폼 설정의 &lt;em>Include Platforms&lt;/em> 설정을 &lt;em>Editor&lt;/em>만 허용하도록 변경하는 것입니다.&lt;/p>
&lt;h2 id="테스트-실행">테스트 실행&lt;/h2>
&lt;p>준비가 끝났다면 이제 테스트를 작성하고 에디터에서 실행해보면 됩니다. 결과는 테스트 러너 창에서 바로 확인이 가능합니다.&lt;/p>
&lt;figure>
&lt;img src="test-result.png"
alt="테스트 실행 결과"/> &lt;figcaption>
&lt;p>테스트 실행 결과&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>현재 프로젝트에서도 아직은 테스트가 붙어있지 않은 코드가 더 많지만, Unity 테스트 러너를 도입한 이후에는 가능하면 버그 수정이나 새로운 기능 추가 시 테스트를 함께 작성하고 있으며, 덕분에 매번 게임을 실행해서 확인해야 했던 연출이나 로직 확인에 많은 시간을 줄일 수 있었습니다.&lt;br>
Unity를 사용하는 다른 프로젝트에서도 기회가 될 때 도입한다면, 생산성 향상에 많은 도움이 될 것으로 생각합니다. 감사합니다!&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>심지어 플레이 모드 테스트는 해당 플랫폼용으로 빌드된 플레이어로 알아서 빌드 후 실행까지 가능합니다. &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>에디터에서 테스트 러너 생성 시 별도 설정을 하지 않았다면 &lt;em>Assets/Tests/Test.asmdef&lt;/em>로 생성됩니다. &lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></content><author><name>양천웅</name><uri>https://github.com/ipdae</uri><email>yang@planetariumhq.com</email></author></entry></feed>